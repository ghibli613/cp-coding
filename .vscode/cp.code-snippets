{
    "brute_backtracking": {
        "prefix": "brute_backtracking",
        "body": [
            "void backtracking(vector<int>& curState, int i, int sum)",
            "{",
            "    if(best_length == curState.size())",
            "    {",
            "        return;",
            "    }",
            "    if(i == n)",
            "    {",
            "        best = curState;",
            "        best_length = best.size();",
            "        return;",
            "    }",
            "    for(int j = 0; j < i; j++)",
            "    {",
            "        curState.push_back(a[j]);",
            "        backtracking(curState, j + 1, sum + a[j]);",
            "        curState.pop_back();",
            "    }",
            "}"
        ],
        "description": "brute_backtracking"
    },
    "data_dsu": {
        "prefix": "data_dsu",
        "body": [
            "struct DisjointSet",
            "{",
            "    vector<int> parent, Rank;",
            "    DisjointSet(int n): parent(n + 1), Rank(n + 1, 0)",
            "    {",
            "        for (int i=1; i<=n; i++) parent[i] = i;",
            "    }",
            "    int findSet(int u)",
            "    {",
            "        if (parent[u] != u) parent[u] = findSet(parent[u]);",
            "        return parent[u];",
            "    }",
            "    bool unionSet(int u, int v)",
            "    {",
            "        int pu = findSet(u), pv = findSet(v);",
            "        if(pu == pv) return false;",
            "        if(Rank[pu] > Rank[pv]) parent[pv] = pu;",
            "        else if(Rank[pu] < Rank[pv]) parent[pu] = pv;",
            "        else",
            "        {",
            "            parent[pv] = pu;",
            "            Rank[pu]++;",
            "        }",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "data_dsu"
    },
    "data_indexedSet": {
        "prefix": "data_indexedSet",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template<typename T>",
            "using indexed_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;"
        ],
        "description": "data_indexedSet"
    },
    "data_LazySegTree": {
        "prefix": "data_LazySegTree",
        "body": [
            "template <class T>",
            "struct LazySegTree",
            "{",
            "    vector<T> seg, lazy;",
            "    int n;",
            "",
            "    LazySegTree(int n_)",
            "    {",
            "        n = n_;",
            "        seg.assign(4 * n, 0);",
            "        lazy.assign(4 * n, 0);",
            "    }",
            "",
            "    LazySegTree(const vector<T> &a) : LazySegTree((int)a.size())",
            "    {",
            "        buildTree(a, 0, 0, n - 1);",
            "    }",
            "",
            "    void buildTree(const vector<T> &a, int id, int l, int r)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        buildTree(a, 2 * id + 1, l, m);",
            "        buildTree(a, 2 * id + 2, m + 1, r);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    void down(int id, int l, int r)",
            "    {",
            "        if (l != r)",
            "        {",
            "            lazy[2 * id + 1] += lazy[id];",
            "            lazy[2 * id + 2] += lazy[id];",
            "        }",
            "        seg[id] += lazy[id];",
            "        lazy[id] = 0;",
            "    }",
            "",
            "    void lazyUpdate(int id, int l, int r, int fr, int to, T val)",
            "    {",
            "        if (lazy[id] != 0)",
            "            down(id, l, r);",
            "        if (fr > r || to < l)",
            "            return;",
            "        if (fr <= l && r <= to)",
            "        {",
            "            seg[id] += val;",
            "            if (l != r)",
            "            {",
            "                lazy[2 * id + 1] += val;",
            "                lazy[2 * id + 2] += val;",
            "            }",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        lazyUpdate(2 * id + 1, l, m, fr, to, val);",
            "        lazyUpdate(2 * id + 2, m + 1, r, fr, to, val);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    T lazyMinQuery(int id, int l, int r, int fr, int to)",
            "    {",
            "        if (lazy[id] != 0)",
            "            down(id, l, r);",
            "        if (fr > r || to < l)",
            "            return INT_MAX;",
            "        if (fr <= l && r <= to)",
            "            return seg[id];",
            "",
            "        int m = (l + r) / 2;",
            "",
            "        return min(",
            "            lazyMinQuery(2 * id + 1, l, m, fr, to),",
            "            lazyMinQuery(2 * id + 2, m + 1, r, fr, to));",
            "    }",
            "};"
        ],
        "description": "data_LazySegTree"
    },
    "data_SegTree": {
        "prefix": "data_SegTree",
        "body": [
            "template <class T>",
            "struct SegTree",
            "{",
            "    vector<T> seg;",
            "    int n;",
            "",
            "    SegTree(int n_)",
            "    {",
            "        n = n_;",
            "        seg.assign(4 * n, 0);",
            "    }",
            "",
            "    SegTree(const vector<T> &a) : SegTree((int)a.size())",
            "    {",
            "        buildTree(a, 0, 0, n - 1);",
            "    }",
            "",
            "    void buildTree(const vector<T> &a, int id, int l, int r)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        buildTree(a, 2 * id + 1, l, m);",
            "        buildTree(a, 2 * id + 2, m + 1, r);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    T queryMin(int id, int l, int r, int fr, int to)",
            "    {",
            "        if (fr <= l && r <= to)",
            "            return seg[id];",
            "        if (fr > r || to < l)",
            "            return INT_MAX;",
            "",
            "        int m = (l + r) / 2;",
            "",
            "        return min(",
            "            queryMin(2 * id + 1, l, m, fr, to),",
            "            queryMin(2 * id + 2, m + 1, r, fr, to));",
            "    }",
            "",
            "    void updateMin(int id, int l, int r, int pos, T val)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = val;",
            "            return;",
            "        }",
            "",
            "        int m = (l + r) / 2;",
            "        if (pos <= m)",
            "            updateMin(2 * id + 1, l, m, pos, val);",
            "        else",
            "            updateMin(2 * id + 2, m + 1, r, pos, val);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "};"
        ],
        "description": "data_SegTree"
    },
    "data_FenwickTree_point_range": {
        "prefix": "data_FenwickTree_point_range",
        "body": [
            "template <class T>",
            "struct FenwickTree",
            "{",
            "    int n;",
            "    vector<T> f;",
            "",
            "    FenwickTree(int n_)",
            "    {",
            "        n = n_;",
            "        f.assign(n + 7, 0);",
            "    }",
            "",
            "    void update(int id, int val)",
            "    {",
            "        while (id <= n)",
            "        {",
            "            f[id] += val;",
            "            id += id & -id;",
            "        }",
            "    }",
            "",
            "    T getSum(int id)",
            "    {",
            "        T sum = 0;",
            "        while (id > 0)",
            "        {",
            "            sum += f[id];",
            "            id -= id & -id;",
            "        }",
            "        return sum;",
            "    }",
            "",
            "    T sumRange(int l, int r)",
            "    {",
            "        return getSum(r) - getSum(l);",
            "    }",
            "",
            "    void updateRange(int l, int r, T val)",
            "    {",
            "        update(l, val);",
            "        update(r + 1, -val);",
            "    }",
            "};"
        ],
        "description": "data_FenwickTree_point_range"
    },
    "data_FenwickTree_range_range": {
        "prefix": "data_FenwickTree_range_range",
        "body": [
            "// @brief This Fenwick tree manages from 1 index",
            "template <class T>",
            "struct FenwickTree",
            "{",
            "    int n;",
            "    vector<T> f1, f2;",
            "",
            "    FenwickTree(int n_)",
            "    {",
            "        n = n_;",
            "        f1.assign(n + 7, 0);",
            "        f2.assign(n + 7, 0);",
            "    }",
            "",
            "    void update(vector<T> &f, int id, int val)",
            "    {",
            "        while (id <= n)",
            "        {",
            "            f[id] += val;",
            "            id += id & -id;",
            "        }",
            "    }",
            "",
            "    T getSum(vector<T> &f, int id)",
            "    {",
            "        T sum = 0;",
            "        while (id > 0)",
            "        {",
            "            sum += f[id];",
            "            id -= id & -id;",
            "        }",
            "        return sum;",
            "    }",
            "",
            "    void updateRange(int l, int r, T val)",
            "    {",
            "        update(f1, l, val);",
            "        update(f1, r + 1, -val);",
            "        update(f2, l, val * (l - 1));",
            "        update(f2, r + 1, -val * r);",
            "    }",
            "",
            "    T prefixSum(int id)",
            "    {",
            "        return getSum(f1, id) * id - getSum(f2, id);",
            "    }",
            "",
            "    T sumRange(int l, int r)",
            "    {",
            "        return prefixSum(r) - prefixSum(l - 1);",
            "    }",
            "};"
        ],
        "description": "data_FenwickTree_range_range"
    },
    "data_SparseTable_rmq": {
        "prefix": "data_SparseTable_rmq",
        "body": [
            "template <class T>",
            "struct SparseTable",
            "{",
            "    int level, n; // 2^MAX_LOG >= n",
            "    vector<vector<T>> f;",
            "    vector<T> log_2;",
            "",
            "    SparseTable(int n_)",
            "    {",
            "        n = n_;",
            "        level = ceil(log2(n));",
            "        f.assign(n, vector<T>(level + 1, 0));",
            "        log_2.assign(n_log + 1, 0);",
            "    }",
            "",
            "    void compute_spare_table(const vector<T> &a)",
            "    {",
            "        for (int i = 0; i < n; i++)",
            "            f[i][0] = a[i];",
            "",
            "        for (int j = 1; (1 << j) <= n; j++)",
            "        {",
            "            int step = 1 << (j - 1);",
            "            for (int i = 0; i + 2 * step <= n; i++)",
            "            {",
            "                f[i][j] = min(f[i][j - 1], f[i + step][j - 1]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T minQuery(int l, int r)",
            "    {",
            "        int k = log_2[r - l + 1];",
            "        return min(f[l][k], f[r - (1 << k) + 1][k]);",
            "    }",
            "",
            "    void compute_log()",
            "    {",
            "        log_2[1] = 0;",
            "        for (int i = 2; i <= n; i++)",
            "        {",
            "            log_2[i] = log_2[i / 2] + 1;",
            "        }",
            "    }",
            "};"
        ],
        "description": "data_SparseTable_rmq"
    },
    "data_SparseTable_rsq": {
        "prefix": "data_SparseTable_rsq",
        "body": [
            "template <class T>",
            "struct SparseTable",
            "{",
            "    int level, n; // 2^MAX_LOG >= n",
            "    vector<vector<T>> f;",
            "    vector<T> log_2;",
            "",
            "    SparseTable(int n_)",
            "    {",
            "        n = n_;",
            "        level = ceil(log2(n));",
            "        f.assign(n, vector<T>(level + 1, 0));",
            "        log_2.assign(n_log + 1, 0);",
            "    }",
            "",
            "    void compute_spare_table(const vector<T> &a)",
            "    {",
            "        for (int i = 0; i < n; i++)",
            "            f[i][0] = a[i];",
            "",
            "        for (int j = 1; (1 << j) <= n; j++)",
            "        {",
            "            int step = 1 << (j - 1);",
            "            for (int i = 0; i + 2 * step <= n; i++)",
            "            {",
            "                f[i][j] = f[i][j - 1] + f[i + step][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    T sumQuery(int l, int r)",
            "    {",
            "        int k, total = 0;",
            "        for (int k = n_log; k >= 0; k--)",
            "        {",
            "            if (l + (1 << k) - 1 <= r)",
            "            {",
            "                total += f[l][k];",
            "                l += 1 << k;",
            "            }",
            "        }",
            "        return total;",
            "    }",
            "",
            "    void compute_log()",
            "    {",
            "        log_2[1] = 0;",
            "        for (int i = 2; i <= n; i++)",
            "        {",
            "            log_2[i] = log_2[i / 2] + 1;",
            "        }",
            "    }",
            "};"
        ],
        "description": "data_SparseTable_rsq"
    },
    "divideConquer_closestPairPoints": {
        "prefix": "divideConquer_closestPairPoints",
        "body": [
            "const int INF = 1e9;",
            "",
            "struct Point",
            "{",
            "    int x, y;",
            "    Point(int x = 0, int y = 0) : x(x), y(y){}",
            "};",
            "",
            "int xCompare(const Point& p1, const Point& p2)",
            "{",
            "    return p1.x < p2.x;",
            "}",
            "",
            "int yCompare(const Point& p1, const Point& p2)",
            "{",
            "    return p1.y < p2.y;",
            "}",
            "",
            "double dist(Point p1, Point p2)",
            "{",
            "    double dx = 1.0 * (p1.x - p2.x) * (p1.x - p2.x);",
            "    double dy = 1.0 * (p1.y - p2.y) * (p1.y - p2.y);",
            "    return sqrt(dx + dy);",
            "}",
            "",
            "double stripClosest(vector<Point> points, int n, double d)",
            "{",
            "    double res = d;",
            "    sort(points.begin(), points.end(), yCompare);",
            "    for(int i = 0; i < n; i++)",
            "        for(int j = i + 1; j < n && points[j].y - points[i].y <= res; j++)",
            "        {",
            "            res = min(res, dist(points[i], points[j]));",
            "        }",
            "    return res;",
            "}",
            "",
            "double closestPair(vector<Point>& points, int left, int right)",
            "{",
            "    if(left >= right) return INF;",
            "    if(right - left == 1) return dist(points[left], points[right]);",
            "",
            "    int mid = (left + right) / 2;",
            "    Point pMid = points[mid];",
            "    double minLeft = closestPair(points, left, mid);",
            "    double minRight = closestPair(points, mid + 1, right);",
            "    double res = min(minLeft, minRight);",
            "",
            "    vector<Point> strip;",
            "    for(int i = left; i <= right; i++)",
            "        if(abs(points[i].x - pMid.x) <= res)",
            "            strip.push_back(points[i]);",
            "",
            "    res = min(res, stripClosest(strip, strip.size(), res));",
            "    return res;",
            "}",
            "",
            "void test()",
            "{",
            "    int n; cin >> n;",
            "    vector<Point> points(n);",
            "    for(int i = 0; i < n; i++) cin >> points[i].x >> points[i].y;",
            "",
            "    sort(points.begin(), points.end(), xCompare);",
            "    double res = closestPair(points, 0, n - 1);",
            "    cout << res << \"\\n\";",
            "",
            "    return 0;",
            "}"
        ],
        "description": "divideConquer_closestPairPoints"
    },
    "divideConquer_countInversions": {
        "prefix": "divideConquer_countInversions",
        "body": [
            "int merge(vector<int> &a, int l, int m, int r)",
            "{",
            "    vector<int> b(a.begin() + l, a.begin() + m + 1);",
            "    vector<int> c(a.begin() + m + 1, a.begin() + r + 1);",
            "    int nB = m - l + 1, nC = r - m;",
            "    int i = 0, j = 0, k = l;",
            "    while(i < nB && j < nC)",
            "    {",
            "        if(b[i] > c[j])",
            "        {",
            "            a[k++] = c[j++];",
            "        }",
            "        else",
            "        {",
            "            a[k++] = b[i++];",
            "            cnt += j;",
            "        }",
            "    }",
            "    while(i < nB)",
            "    {",
            "        a[k++] = b[i++];",
            "        cnt += j;",
            "    }",
            "    while(j < nC)",
            "    {",
            "        a[k++] = c[j++];",
            "    }",
            "    return cnt;",
            "}",
            "",
            "int countInversions(vector<int> &a, int l, int r)",
            "{",
            "    if(l >= r) return 0;",
            "    int m = (l + r) / 2;",
            "    // Chia va tri",
            "    int countLeft = countInversions(a, l, m);",
            "    int countRight = countInversions(a, m + 1, r);",
            "    // Gop",
            "    int countMid = merge(a, l, m, r);",
            "    return countLeft + countRight + countMid;",
            "}"
        ],
        "description": "divideConquer_countInversions"
    },
    "dynamic_coinChange": {
        "prefix": "dynamic_coinChange",
        "body": [
            "int coinChange(vector<int> &coins, int n, int w)",
            "{",
            "    dp[0] = 0;",
            "    for(int i = 1; i <= w; i++)",
            "        dp[i] = INF;",
            "",
            "    for(int i = 1; i <= n; i++)",
            "        for(int j = coins[i - 1]; j <= w; j++)",
            "            dp[j] = min(dp[j], dp[j - coins[i - 1]] + 1);",
            "",
            "    return dp[w];",
            "}",
            "",
            "void trace(vector<int> &coins, int n, int w)",
            "{",
            "    while(w > 0)",
            "    {",
            "        if(w >= coins[n - 1] && dp[w] == dp[w - coins[n - 1]] + 1)",
            "        {",
            "            cout << coins[n - 1] << \" \";",
            "            w -= coins[n - 1];",
            "        }",
            "        else",
            "            n -= 1;",
            "    }",
            "}"
        ],
        "description": "dynamic_coinChange"
    },
    "dynamic_lcs": {
        "prefix": "dynamic_lcs",
        "body": [
            "int lcs(vector<int> &a, vector<int> &b)",
            "{",
            "    int n = a.size();",
            "    int m = b.size();",
            "",
            "    for (int i = 0; i <= n; i++)",
            "        dp[i][0] = 0;",
            "    for (int j = 0; j <= m; j++)",
            "        dp[0][j] = 0;",
            "",
            "    for (int i = 1; i <= n; i++)",
            "        for (int j = 1; j <= m; j++)",
            "            if (a[i - 1] == b[j - 1])",
            "                dp[i][j] = dp[i - 1][j - 1] + 1;",
            "            else",
            "                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);",
            "",
            "    return dp[n][m];",
            "}",
            "",
            "void trace(vector<int>& a, vector<int>& b)",
            "{",
            "    int n = a.size(), m = b.size();",
            "",
            "    vector<int> res;",
            "    while(n > 0 && m > 0)",
            "    {",
            "        if(a[n - 1] == b[m - 1])",
            "        {",
            "            res.push_back(a[n - 1]);",
            "            n--;",
            "            m--;",
            "        }",
            "        else if(dp[n - 1][m] > dp[n][m - 1])",
            "            n--;",
            "        else",
            "            m--;",
            "    }",
            "    for(int i = res.size() - 1; i >= 0; i++)",
            "        cout << res[i] << \" \";",
            "}"
        ],
        "description": "dynamic_lcs"
    },
    "dynamic_lis": {
        "prefix": "dynamic_lis",
        "body": [
            "int LIS(vector<int>& A, vector<int>& dp, vector<int> & prev)",
            "{",
            "    int n = A.size();",
            "    vector<int> lis, lis_index;",
            "    dp.assign(n, 1);",
            "    prev.assign(n, -1);",
            "",
            "    for(int j, i = 0; i < n; i++)",
            "    {",
            "        j = upper_bound(lis.begin(), lis.end(), A[i]) - lis.begin();",
            "        dp[i] = j + 1;",
            "        if(j != 0)",
            "        {",
            "            prev[i] = lis_index[j - 1];",
            "        }",
            "        if(j == (int)lis.size())",
            "        {",
            "            lis.push_back(A[i]);",
            "            lis_index.push_back(i);",
            "        }",
            "        else",
            "        {",
            "            lis[j] = A[i];",
            "            lis_index[j] = i;",
            "        }",
            "    }",
            "",
            "    return lis_index[(int)lis.size() - 1];",
            "}",
            "",
            "void trace(vector<int>& A, vector<int>& prev, int pos)",
            "{",
            "    vector<int> b;",
            "    while(pos != -1)",
            "    {",
            "        b.push_back(A[pos]);",
            "        pos = prev[pos];",
            "    }",
            "",
            "    for(int i = (int)b.size() - 1; i >= 0; i--)",
            "        cout << b[i] << ' ';",
            "    cout << '\\n';",
            "}",
            "",
            "void test()",
            "{",
            "    int n; cin >> n;",
            "",
            "    vector<int> A(n);",
            "    for(int i = 0; i < n; i++)",
            "        cin >> A[i];",
            "",
            "    vector<int> dp, prev;",
            "    int pos = LIS(A, pd, prev);",
            "",
            "    cout << \"LIS: \" << dp[pos] << \"\\n\";",
            "    trace(A, prev, pos);",
            "}"
        ],
        "description": "dynamic_lis"
    },
    "dynamic_knapsack_nSpace": {
        "prefix": "dynamic_knapsack_nSpace",
        "body": [
            "int knapsack(int N, int W)",
            "{",
            "    dp.assign(W + 1, 0);",
            "",
            "    for(int i = 0; i < N; i++)",
            "        for(int j = W; j >= weight[i]; j--)",
            "        {",
            "            if(dp[j] < dp[j - weight[i]] + profit[i])",
            "                dp[j] = dp[j - weight[i]] + profit[i];",
            "        }",
            "",
            "    return dp[W];",
            "}"
        ],
        "description": "dynamic_knapsack_nSpace"
    },
    "dynamic_knapsack_nwSpace": {
        "prefix": "dynamic_knapsack_nwSpace",
        "body": [
            "vector<int> weight, profit;",
            "vector<vector<int>> dp;",
            "",
            "int knapsack(int N, int W)",
            "{",
            "    dp.assign(N + 1, vector<int>(W + 1, 0));",
            "",
            "    for (int j = 0; j <= W; j++)",
            "        dp[0][j] = 0;",
            "",
            "    for (int i = 1; i <= N; i++)",
            "        for (int j = 0; j <= W; j++)",
            "        {",
            "            dp[i][j] = dp[i - 1][j];",
            "            if (j >= weight[i - 1] && dp[i][j] < dp[i - 1][j - weight[i - 1]] + profit[i - 1])",
            "            {",
            "                dp[i][j] = dp[i - 1][j - weight[i - 1]] + profit[i - 1];",
            "            }",
            "        }",
            "",
            "    return dp[N][W];",
            "}",
            "",
            "void trace(int N, int W)",
            "{",
            "    int totalWeight = 0, totalProfit = 0;",
            "    while (N > 0 && W > 0)",
            "    {",
            "        if (weight[N - 1] <= W && dp[N][W] == dp[N - 1][W - weight[N - 1]] + profit[N - 1])",
            "        {",
            "            cout << weight[N - 1] << \" - \" << profit[N - 1] << \"\\n\";",
            "            totalWeight += weight[N - 1];",
            "            totalProfit += profit[N - 1];",
            "            W -= weight[N - 1];",
            "        }",
            "        N--;",
            "    }",
            "    cout << \"Total weight: \" << totalWeight << \"\\n\";",
            "    cout << \"Total profit: \" << totalProfit << \"\\n\";",
            "}",
            "",
            "void test()",
            "{",
            "    int n, w; cin >> n >> w;",
            "    weight.resize(n);",
            "    profit.resize(n);",
            "    for(int i = 0; i < n; i++)",
            "        cin >> weight[i] >> profit[i];",
            "",
            "    knapsack(n, w);",
            "    trace(n, w);",
            "}"
        ],
        "description": "dynamic_knapsack_nwSpace"
    },
    "geometry_rectangle_geometry": {
        "prefix": "geometry_rectangle_geometry",
        "body": [
            "struct Rect {",
            "\tint x1, y1, x2, y2;",
            "\tint area() { return (y2 - y1) * (x2 - x1); }",
            "};",
            "",
            "int intersect(Rect p, Rect q) {",
            "\tint xOverlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1));",
            "\tint yOverlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1));",
            "\treturn xOverlap * yOverlap;",
            "}"
        ],
        "description": "geometry_rectangle_geometry"
    },
    "graph_lca_binaryLifting": {
        "prefix": "graph_lca_binaryLifting",
        "body": [
            "int n, level;",
            "vector<vector<int>> graph;",
            "int counter;",
            "vector<int> tin, tout;",
            "vector<vector<int>> parent;",
            "",
            "void dfs(int u, int p)",
            "{",
            "    tin[u] = ++counter;",
            "",
            "    parent[u][0] = p;",
            "    for(int v : graph[u])",
            "        if(v != p)",
            "            dfs(v, u);",
            "",
            "    tout[u] = ++counter;",
            "}",
            "",
            "void preprocess(int root)",
            "{",
            "    counter = 0;",
            "    dfs(root, root);",
            "",
            "    for(int k = 1; k < level; k++)",
            "        for(int i = 1; i <= n; i++)",
            "            parent[i][k] = parent[parent[i][k - 1]][k - 1];",
            "}",
            "",
            "int isAncestor(int u, int v)",
            "{",
            "    return tin[u] <= tin[v] && tin[v] <= tout[u];",
            "}",
            "",
            "int lca(int u, int v)",
            "{",
            "    if(isAncestor(u, v)) return u;",
            "    if(isAncestor(v, u)) return v;",
            "",
            "    for(int k = level - 1; k >= 0; k--)",
            "        if(!isAncestor(parent[u][k], v))",
            "            u = parent[u][k];",
            "",
            "    return parent[u][0];",
            "}",
            "",
            "void test()",
            "{",
            "    int q, u, v;",
            "    cin >> n;",
            "    graph.assign(n + 1, vector<int>());",
            "    tin.assign(n + 1, 0); tout.assign(n + 1, 0);",
            "",
            "    level = ceil(log2(n));",
            "    parent.assign(n + 1, vector<int>(level));",
            "",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "    preprocess();",
            "    cin >> q;",
            "    while(q--)",
            "    {",
            "        cin >> u >> v;",
            "        cout << lca(u, v) << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "graph_lca_binaryLifting"
    },
    "graph_lca_sqrtDecomposition": {
        "prefix": "graph_lca_sqrtDecomposition",
        "body": [
            "int n;",
            "vector<vector<int>> graph;",
            "int block_size;",
            "vector<int> level, parent, jump_parent;",
            "",
            "int getDepth(int u, int p)",
            "{",
            "    int res = 0;",
            "    for(int v : graph[u])",
            "        if(v != p)",
            "            res = max(res, getDepth(v, u));",
            "    return res + 1;",
            "}",
            "",
            "void dfs(int u, int p)",
            "{",
            "    level[u] = level[p] + 1;",
            "    parent[u] = p;",
            "    if(level[u] % block_size == 0)",
            "        jump_parent[u] = p;",
            "    else",
            "        jump_parent[u] = jump_parent[p];",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(v != p)",
            "            dfs(v, u);",
            "    }",
            "}",
            "",
            "void preprocess()",
            "{",
            "    int height = getDepth(0, 1);",
            "    block_size = sqrt(height);",
            "    level[0] = -1;",
            "    dfs(1, 0);",
            "}",
            "",
            "int lca(int u, int v)",
            "{",
            "    if(level[u] > level[v]) swap(u, v);",
            "    while(level[u] < level[v])",
            "    {",
            "        if(level[jump_parent[v]] > level[u])",
            "            v = jump_parent[v];",
            "        else",
            "            v = parent[v];",
            "    }",
            "    while (u != v)",
            "    {",
            "        if(jump_parent[u] == jump_parent[v])",
            "        {",
            "            u = parent[u];",
            "            v = parent[v];",
            "        }",
            "        else",
            "        {",
            "            u = jump_parent[u];",
            "            v = jump_parent[v];",
            "        }",
            "    }",
            "",
            "    return u;",
            "}",
            "",
            "void test()",
            "{",
            "    int q, u, v;",
            "    cin >> n;",
            "    graph.assign(n + 1, vector<int>());",
            "    level.assign(n + 1);",
            "    parent.assign(n + 1);",
            "    jump_parent.assign(n + 1);",
            "",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "    preprocess();",
            "    cin >> q;",
            "    while(q--)",
            "    {",
            "        cin >> u >> v;",
            "        cout << lca(u, v) << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "graph_lca_sqrtDecomposition"
    },
    "graph_mst_kruskal": {
        "prefix": "graph_mst_kruskal",
        "body": [
            "typedef pair<int, int> pii;",
            "typedef pair<int, pii> piii;",
            "",
            "vector<piii> edges;",
            "int n, m;",
            "",
            "struct DisjointSet",
            "{",
            "    vector<int> parent, Rank;",
            "    DisjointSet(int n): parent(n + 1), Rank(n + 1, 0)",
            "    {",
            "        for (int i=1; i<=n; i++) parent[i] = i;",
            "    }",
            "    int findSet(int u)",
            "    {",
            "        if (parent[u] != u) parent[u] = findSet(parent[u]);",
            "        return parent[u];",
            "    }",
            "    bool unionSet(int u, int v)",
            "    {",
            "        int pu = findSet(u), pv = findSet(v);",
            "        if(pu == pv) return false;",
            "        if(Rank[pu] > Rank[pv]) parent[pv] = pu;",
            "        else if(Rank[pu] < Rank[pv]) parent[pu] = pv;",
            "        else",
            "        {",
            "            parent[pv] = pu;",
            "            Rank[pu]++;",
            "        }",
            "        return true;",
            "    }",
            "};",
            "",
            "int kruskal()",
            "{",
            "    int mst = 0;",
            "    int cnt = 0;",
            "",
            "    sort(edges.begin(), edges.end());",
            "    DisjointSet dsu(n);",
            "",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        u = edges[i].second.first;",
            "        v = edges[i].second.second;",
            "        w = edges[i].first;",
            "",
            "        if(dsu.unionSet(u, v))",
            "        {",
            "            cnt++;",
            "            mst += w;",
            "        }",
            "    }",
            "    return cnt == n - 1 ? mst : -1;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        edges.push_back(make_pair(w, make_pair(u, v)));",
            "    }",
            "",
            "    int mst = kruskal();",
            "    if(mst == -1)",
            "        cout << \"Graph is not connect\\n\";",
            "    else",
            "        cout << mst << \"\\n\";",
            "}"
        ],
        "description": "graph_mst_kruskal"
    },
    "graph_mst_prim": {
        "prefix": "graph_mst_prim",
        "body": [
            "const int INF = 1e9;",
            "",
            "typedef pair<int, int> pii;",
            "",
            "vector<int> dist, path;",
            "vector<bool> visited;",
            "vector<vector<pii>> adj;",
            "int n, m;",
            "",
            "bool prim()",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    visited.assign(n, false);",
            "",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, 0});",
            "    dist[0] = 0;",
            "",
            "    int count = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(visited[u]) continue;",
            "        visited[u] = true;",
            "        count++;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(!visited[v] && dist[v] > w)",
            "            {",
            "                dist[v] = w;",
            "                path[v] = u;",
            "                pq.push({w, v});",
            "            }",
            "        }",
            "    }",
            "    return count == n;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "",
            "    adj.assign(n, vector<pii>());",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        adj[u].push_back({v, w});",
            "        adj[v].push_back({u, w});",
            "    }",
            "",
            "    if(!prim()) cout << \"Graph is not connect\\n\";",
            "    else",
            "    {",
            "        int mst = 0;",
            "        for(int i = 0; i < n; i++)",
            "            mst += dist[i];",
            "        cout << \"MST: \" << mst << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "graph_mst_prim"
    },
    "graph_path_findEulerCycle": {
        "prefix": "graph_path_findEulerCycle",
        "body": [
            "vector<vector<int>> deg;",
            "int n, m;",
            "vector<int> result;",
            "",
            "void findEulerPath(int u)",
            "{",
            "    for(int v = 0; v < n; v++)",
            "    {",
            "        if(deg[u][v] > 0)",
            "        {",
            "            deg[u][v]--;",
            "            deg[v][u]--;",
            "            findEulerPath(v);",
            "        }",
            "    }",
            "    result.push_back(u);",
            "}",
            "",
            "void test()",
            "{",
            "    // Read data",
            "    cin >> n >> m;",
            "    deg.assign(n + 1, vector<int>(n + 1, 0));",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        deg[u][v]++;",
            "        deg[v][u]++;",
            "    }",
            "",
            "    int u = -1, v = -1;",
            "    bool isConnected = true, bad = false;",
            "",
            "    // check the degree",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        int cnt = 0;",
            "        for(int j = 0; j < n; j++)",
            "            cnt += deg[i][j];",
            "",
            "        if(cnt % 2 == 1)",
            "        {",
            "            if(u == -1)",
            "                u = i;",
            "            else if(v == -1)",
            "                v = i;",
            "            else",
            "            {",
            "                bad = true;",
            "                break;",
            "            }",
            "        }",
            "    }",
            "",
            "    // check and print cycle",
            "    if(bad)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u != -1)",
            "    {",
            "        deg[u][v]++; deg[v][u]++;",
            "        m++;",
            "    }",
            "    findEulerPath(0);",
            "    if((int)result.size() != m + 1)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u == -1)",
            "    {",
            "        cout << \"Euler cycle: \";",
            "        for(int v : result)",
            "            cout << v << \" \";",
            "        return;",
            "    }",
            "",
            "    for(int i = 0; i < (int)result.size(); i++)",
            "    {",
            "        if((result[i] == u && result[i + 1] == v) || (result[i] == v && result[i + 1] == u))",
            "        {",
            "            for(int j = 1; j <= i; j++)",
            "                result.push_back(result[j]);",
            "            result.erase(result.begin(), result.begin() + i + 1);",
            "            break;",
            "        }",
            "    }",
            "",
            "    cout << \"Euler Path: \";",
            "    for(int v : result)",
            "        cout << v << \" \";",
            "}"
        ],
        "description": "graph_path_findEulerCycle"
    },
    "graph_path_findEulerPath": {
        "prefix": "graph_path_findEulerPath",
        "body": [
            "vector<vector<int>> deg;",
            "int n, m;",
            "vector<int> result;",
            "",
            "void findEulerPath(int u)",
            "{",
            "    for(int v = 0; v < n; v++)",
            "    {",
            "        if(deg[u][v] > 0)",
            "        {",
            "            deg[u][v]--;",
            "            deg[v][u]--;",
            "            findEulerPath(v);",
            "        }",
            "    }",
            "    result.push_back(u);",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    deg.assign(n + 1, vector<int>(n + 1, 0));",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        deg[u][v]++;",
            "        deg[v][u]++;",
            "    }",
            "",
            "    findEulerPath(0);",
            "    for(int v : result)",
            "    {",
            "        cout << v << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_path_findEulerPath"
    },
    "graph_path_findHamiltonPath": {
        "prefix": "graph_path_findHamiltonPath",
        "body": [
            "vector<vector<int>> graph;",
            "int n, m;",
            "vector<int> path;",
            "vector<int> visited;",
            "",
            "void findHamiltonPath(int u)",
            "{",
            "    if((int)path.size()== n)",
            "    {",
            "        bool hasCycle = false;",
            "        for(int v : graph[u])",
            "            if(v == path[0])",
            "            {",
            "                hasCycle = true;",
            "                break;",
            "            }",
            "        if(hasCycle)",
            "            cout << \"found a Hamilton cycle\";",
            "        else",
            "            cout << \"found a Hamilton path\";",
            "        return;",
            "    }",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!visited[v])",
            "        {",
            "            visited[v] = true;",
            "            path.push_back(v);",
            "            findHamiltonPath(v);",
            "            path.pop_back();",
            "            visited[v] = false;",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_path_findHamiltonPath"
    },
    "graph_scc_bridgeCutVertex": {
        "prefix": "graph_scc_bridgeCutVertex",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> low, num;",
            "vector<bool> isCut;",
            "vector<pair<int, int>> bridges;",
            "int n, m;",
            "int counter;",
            "",
            "void dfs(int u, int p)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    int numChild = 0;",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(v == p) continue;",
            "        if(num[v] > 0)",
            "            low[u] = min(low[u], num[v]);",
            "        else",
            "        {",
            "            dfs(v, u);",
            "            low[u] = min(low[u], low[v]);",
            "            numChild++;",
            "            if(low[v] > num[u])",
            "                bridges.push_back(make_pair(u, v));",
            "            if(low[v] >= num[u] && p != -1)",
            "                isCut[u] = true;",
            "        }",
            "    }",
            "    if(p == -1 && numChild > 1)",
            "        isCut[u] = true;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    low.assign(n + 1, 0), num.assign(n + 1, 0);",
            "    isCut.assign(n + 1, false);",
            "    counter = 0;",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(!num[i])",
            "        {",
            "            dfs(i, -1);",
            "        }",
            "    }",
            "",
            "    cout << \"Bridges:\\n\";",
            "    for(int i = 0; i < bridges.size(); i++)",
            "    {",
            "        pair<int, int> b = bridges[i];",
            "        cout << b.first << \" \" << b.second << \"\\n\";",
            "    }",
            "    cout << \"Cut vertices:\";",
            "    for(int i = 1; i <= n; i++)",
            "        if(isCut[i])",
            "            cout << \" \" << i;",
            "    cout << \"\\n\";",
            "}"
        ],
        "description": "graph_scc_bridgeCutVertex"
    },
    "graph_scc_tarjan": {
        "prefix": "graph_scc_tarjan",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> low, num;",
            "vector<bool> found;",
            "stack<int> st;",
            "int n, m;",
            "int counter;",
            "",
            "void dfs(int u)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    st.push(u);",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!found[v])",
            "        {",
            "            if(num[v] > 0)",
            "                low[u] = min(low[u], num[v]);",
            "            else",
            "            {",
            "                dfs(v);",
            "                low[u] = min(low[u], low[v]);",
            "            }",
            "        }",
            "    }",
            "",
            "    if(num[u] == low[u])",
            "    {",
            "        cout << \"Found a SCC:\";",
            "        int v;",
            "        do",
            "        {",
            "            v = st.top();",
            "            st.pop();",
            "            cout << \" \" << v;",
            "            found[v] = true;",
            "        } while(v != u);",
            "        cout << \"\\n\";",
            "    }",
            "}",
            "",
            "void tarjan()",
            "{",
            "    counter = 0;",
            "    low.assign(n + 1, 0);",
            "    num.assign(n + 1, 0);",
            "    found.assign(n + 1, false);",
            "    st = stack<int>();",
            "",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(!num[i])",
            "        {",
            "            dfs(i);",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "    }",
            "    tarjan();",
            "}"
        ],
        "description": "graph_scc_tarjan"
    },
    "graph_shortestPath_bellmanFord": {
        "prefix": "graph_shortestPath_bellmanFord",
        "body": [
            "const int INF = 1e9;",
            "",
            "struct Edge",
            "{",
            "    int u, v, w;",
            "    Edge(int u = 0, int v = 0, int w = 0)",
            "        : u(u), v(v), w(w) {}",
            "};",
            "",
            "vector<int> dist, path;",
            "",
            "int bellmanFord(vector<Edge> &edges, int n, int m, int s)",
            "{",
            "    dist.assign(n + 1, INF);",
            "    path.assign(n + 1, -1);",
            "    dist[s] = 0;",
            "    int u, v, w;",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        for(int j = 0; j < m; j++)",
            "        {",
            "            u = edges[j].u;",
            "            v = edges[j].v;",
            "            w = edges[j].w;",
            "            if(dist[u] != INF && dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "            }",
            "        }",
            "    }",
            "",
            "    // check negative cycle",
            "    for(int j = 0; j < m; j++)",
            "    {",
            "        u = edges[j].u;",
            "        v = edges[j].v;",
            "        w = edges[j].w;",
            "        if(dist[u] != INF && dist[v] > dist[u] + w)",
            "        {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m;",
            "    cin >> n >> m;",
            "",
            "    vector<Edge> edges;",
            "    int u, v, w;",
            "    for(int i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        edges.push_back(Edge(u, v, w));",
            "    }",
            "",
            "    bellmanFord(edges, n, m, 1);",
            "    cout << dist[n];",
            "}"
        ],
        "description": "graph_shortestPath_bellmanFord"
    },
    "graph_shortestPath_dijkstra": {
        "prefix": "graph_shortestPath_dijkstra",
        "body": [
            "const int INF = 1e9;",
            "",
            "typedef pair<int, int> pii;",
            "",
            "vector<int> dist, path;",
            "vector<vector<pii>> adj;",
            "int n, m;",
            "",
            "void dijkstra(int s)",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, s});",
            "    dist[s] = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(tmp.first != dist[u]) continue;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    adj.assign(n, vector<pii>());",
            "    int u, v, w;",
            "    for(int i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        adj[u].push_back({v, w});",
            "    }",
            "",
            "    dijkstra(0);",
            "",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        cout << dist[i] << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_shortestPath_dijkstra"
    },
    "graph_shortestPath_floydWarshall": {
        "prefix": "graph_shortestPath_floydWarshall",
        "body": [
            "const int INF = 1e9;",
            "",
            "vector<vector<int>> dist, path;",
            "",
            "int floydWarshall(vector<vector<int>> &matrix, int n)",
            "{",
            "    dist.assign(n + 1, vector<int>(n + 1));",
            "    path.assign(n + 1, vector<int>(n + 1));",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        for(int j = 1; j <= n; j++)",
            "        {",
            "            dist[i][j] = i == j ? 0 : matrix[i][j];",
            "            if(i != j && dist[i][j] < INF)",
            "            {",
            "                path[i][j] = i;",
            "            }",
            "            else",
            "            {",
            "                path[i][j] = -1;",
            "            }",
            "        }",
            "    }",
            "    for(int k = 1; k <= n; k++)",
            "    {",
            "        for(int i = 1; i <= n; i++)",
            "        {",
            "            if(dist[i][k] >= INF) continue;",
            "            for(int j = 1; j <= n; j++)",
            "            {",
            "                if(dist[k][j] < INF && dist[i][j] > dist[i][k] + dist[k][j])",
            "                {",
            "                    dist[i][j] = dist[i][k] + dist[k][j];",
            "                    path[i][j] = path[k][j];",
            "                }",
            "            }",
            "        }",
            "    }",
            "    // check negative cycle",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(dist[i][i] < 0) return false;",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m;",
            "    cin >> n >> m;",
            "",
            "    vector<vector<int>> matrix(n + 1, vector<int>(n + 1, INF));",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        matrix[u][v] = w;",
            "    }",
            "",
            "    floydWarshall(matrix, n);",
            "    for(int i = 1; i <= n; i++)",
            "        cout << dist[1][i] << \" \";",
            "}"
        ],
        "description": "graph_shortestPath_floydWarshall"
    },
    "graph_topo_dfs": {
        "prefix": "graph_topo_dfs",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> visited;",
            "vector<int> result;",
            "int n, m;",
            "",
            "/*",
            "Value of visited:",
            "- 0: not visit (not process)",
            "- 1: visiting (processing)",
            "- 2: visited (processed)",
            "*/",
            "bool dfs(int u)",
            "{",
            "    visited[u] = 1;",
            "    for(int v : graph[u])",
            "    {",
            "        if(visited[v] == 1) // cycle detected",
            "            return false;",
            "        if(visited[v] == 0)",
            "            if(dfs(v) == false)",
            "            {",
            "                return false;",
            "            }",
            "    }",
            "    result.push_back(u);",
            "    visited[u] = 2;",
            "    return true;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    visited.assign(n + 1, 0);",
            "",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "    }",
            "    bool flag = true;",
            "    for(int i = 1; i <= n && flag == true; i++)",
            "        if(!visited[i])",
            "            flag &= dfs(i);",
            "",
            "    if(!flag)",
            "        cout << \"Graph is not a DAG\";",
            "    else",
            "    {",
            "        for(int i = n - 1; i >= 0; i--)",
            "            cout << result[i] << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_topo_dfs"
    },
    "graph_topo_kahn": {
        "prefix": "graph_topo_kahn",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> indegree;",
            "vector<int> result;",
            "int n, m;",
            "",
            "bool kahn()",
            "{",
            "    queue<int> q;",
            "    for(int i = 1; i <= n; i++)",
            "        if(indegree[i] == 0)",
            "            q.push(i);",
            "",
            "    while(!q.empty())",
            "    {",
            "        int u = q.front(); q.pop();",
            "        result.push_back(u);",
            "        for(int i = 0; i < (int)graph[u].size(); i++)",
            "        {",
            "            indegree[graph[u][i]]--;",
            "            if(indegree[graph[u][i]] == 0)",
            "            {",
            "                q.push(graph[u][i]);",
            "            }",
            "        }",
            "    }",
            "",
            "    return result.size() == n;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    indegree.assign(n + 1, 0);",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        indegree[v]++;",
            "    }",
            "    if(!kahn())",
            "        cout << \"Graph is not a DAG\";",
            "    else",
            "    {",
            "        for(int i = 0; i < n; i++)",
            "            cout << result[i] << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_topo_kahn"
    },
    "graph_topo_sort": {
        "prefix": "graph_topo_sort",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> visited;",
            "vector<int> result;",
            "int n, m;",
            "",
            "void dfs(int u)",
            "{",
            "    visited[u] = true;",
            "    for(int v : graph[u])",
            "    {",
            "        if(!visited[v])",
            "            dfs(v);",
            "    }",
            "    result.push_back(u);",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    visited.assign(n + 1, 0);",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "    }",
            "    for(int i = 1; i <= n; i++)",
            "        if(!visited[i])",
            "            dfs(i);",
            "    for(int i = n - 1; i >= 0; i--)",
            "        cout << result[i] << \" \";",
            "}"
        ],
        "description": "graph_topo_sort"
    },
    "graph_traversal_bfs": {
        "prefix": "graph_traversal_bfs",
        "body": [
            "vector<vector<int>> adj;",
            "vector<int> path;",
            "vector<bool> visited;",
            "",
            "void bfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    queue<int> q;",
            "",
            "    q.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!q.empty())",
            "    {",
            "        u = q.front();",
            "        q.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                q.push(v);",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m; cin >> n >> m;",
            "",
            "    adj.assign(n + 1, vector<int>());",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "    bfs(1);",
            "}"
        ],
        "description": "graph_traversal_bfs"
    },
    "graph_traversal_dfs_recursive": {
        "prefix": "graph_traversal_dfs_recursive",
        "body": [
            "vector<vector<int>> adj;",
            "vector<int> path;",
            "vector<bool> visited;",
            "",
            "void dfs(int s)",
            "{",
            "    visited[s] = true;",
            "",
            "    for(int i = 0; i < (int)adj[s].size(); i++)",
            "    {",
            "        int v = adj[s][i];",
            "",
            "        if(!visited[v])",
            "        {",
            "            path[v] = s;",
            "            dfs(v);",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m; cin >> n >> m;",
            "",
            "    adj.assign(n + 1, vector<int>());",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "",
            "    path.assign(n + 1, -1);",
            "    visited.assign(n + 1, false);",
            "    dfs(1);",
            "}"
        ],
        "description": "graph_traversal_dfs_recursive"
    },
    "graph_traversal_dfs_stack": {
        "prefix": "graph_traversal_dfs_stack",
        "body": [
            "vector<vector<int>> adj;",
            "vector<int> path;",
            "vector<bool> visited;",
            "",
            "void dfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    stack<int> st;",
            "",
            "    st.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!st.empty())",
            "    {",
            "        u = st.top();",
            "        st.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                st.push(v);",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m; cin >> n >> m;",
            "",
            "    adj.assign(n + 1, vector<int>());",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "    dfs(1);",
            "}"
        ],
        "description": "graph_traversal_dfs_stack"
    },
    "misc_compressArray": {
        "prefix": "misc_compressArray",
        "body": [
            "void compressArray(vector<int>& a, int n)",
            "{",
            "    vector<int> b;",
            "    for(int i : a)",
            "        b.push_back(i);",
            "    sort(b.begin(), b.end());",
            "",
            "    unordered_map<int, int> zipIdx;",
            "    int newIdx = 1;",
            "    for(int i = 0; i < n i++)",
            "        if(i == 0 || b[i] != b[i - 1])",
            "        {",
            "            zipIdx[b[i]] = newIdx;",
            "            newIdx++;",
            "        }",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        a[i] = zipIdx[a[i]];",
            "    }",
            "}"
        ],
        "description": "misc_compressArray"
    },
    "misc_debug": {
        "prefix": "misc_debug",
        "body": [
            "void __print(int x) {cerr << x;}",
            "void __print(long x) {cerr << x;}",
            "void __print(long long x) {cerr << x;}",
            "void __print(unsigned x) {cerr << x;}",
            "void __print(unsigned long x) {cerr << x;}",
            "void __print(unsigned long long x) {cerr << x;}",
            "void __print(float x) {cerr << x;}",
            "void __print(double x) {cerr << x;}",
            "void __print(long double x) {cerr << x;}",
            "void __print(char x) {cerr << '\\'' << x << '\\'';}",
            "void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
            "",
            "template<typename T, typename V>",
            "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}",
            "template<typename T>",
            "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}",
            "void _print() {cerr << \"]\\n\";}",
            "template <typename T, typename... V>",
            "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
            "",
            "#define dbg(...) cerr<<__func__<<\":\"<<__LINE__<<\" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__);"
        ],
        "description": "misc_debug"
    },
    "numeric_binarySearch": {
        "prefix": "numeric_binarySearch",
        "body": [
            "int binarySearch(int a[], int left, int right, int x)",
            "{",
            "    int res = right;",
            "    while(left < right)",
            "    {",
            "        int mid = left + (right - left) / 2;",
            "        if(a[mid] >= x)",
            "        {",
            "            res = mid;",
            "            right = mid;",
            "        }",
            "        else",
            "        {",
            "            left = mid + 1;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "numeric_binarySearch"
    },
    "numeric_mint": {
        "prefix": "numeric_mint",
        "body": [
            "template <int MOD>",
            "struct mint",
            "{",
            "\tint v;",
            "\texplicit operator int() const { return v; } // explicit -> don't silently convert to int",
            "\tmint() : v(0) {}",
            "\tmint(ll _v)",
            "\t{",
            "\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "\t\tif (v < 0)",
            "\t\t\tv += MOD;",
            "\t}",
            "\tfriend bool operator==(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn a.v == b.v;",
            "\t}",
            "\tfriend bool operator!=(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn !(a == b);",
            "\t}",
            "\tfriend bool operator<(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn a.v < b.v;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &o)",
            "\t{",
            "\t\tif ((v += o.v) >= MOD)",
            "\t\t\tv -= MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &o)",
            "\t{",
            "\t\tif ((v -= o.v) < 0)",
            "\t\t\tv += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &o)",
            "\t{",
            "\t\tv = int((ll)v * o.v % MOD);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }",
            "\tfriend mint pow(mint a, ll p)",
            "\t{",
            "\t\tmint ans = 1;",
            "\t\tassert(p >= 0);",
            "\t\tfor (; p; p /= 2, a *= a)",
            "\t\t\tif (p & 1)",
            "\t\t\t\tans *= a;",
            "\t\treturn ans;",
            "\t}",
            "\tfriend mint inv(const mint &a)",
            "\t{",
            "\t\tassert(a.v != 0);",
            "\t\treturn pow(a, MOD - 2);",
            "\t}",
            "",
            "\tmint operator-() const { return mint(-v); }",
            "\tmint &operator++() { return *this += 1; }",
            "\tmint &operator--() { return *this -= 1; }",
            "\tfriend mint operator+(mint a, const mint &b) { return a += b; }",
            "\tfriend mint operator-(mint a, const mint &b) { return a -= b; }",
            "\tfriend mint operator*(mint a, const mint &b) { return a *= b; }",
            "\tfriend mint operator/(mint a, const mint &b) { return a /= b; }",
            "\tfriend ostream &operator<<(ostream &os, const mint &m)",
            "\t{",
            "\t\treturn os << m.v;",
            "\t}",
            "\tfriend istream &operator>>(istream &is, mint &m)",
            "\t{",
            "\t\tll x;",
            "\t\tis >> x;",
            "\t\tm.v = x;",
            "\t\treturn is;",
            "\t}",
            "};"
        ],
        "description": "numeric_mint"
    },
    "numeric_prime_isPrime": {
        "prefix": "numeric_prime_isPrime",
        "body": [
            "bool isPrime(int n)",
            "{",
            "    if(n < 2) return false;",
            "    for(int i = 0; i * i <= n; i++)",
            "        if(n % i == 0) return false;",
            "    return true;",
            "}"
        ],
        "description": "numeric_prime_isPrime"
    },
    "numeric_prime_phiEuler": {
        "prefix": "numeric_prime_phiEuler",
        "body": [
            "int phiEuler(int n)",
            "{",
            "    int result = n;",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        if(n % i == 0)",
            "        {",
            "            while(n % i == 0) n /= i;",
            "            result = result / i * (i - 1);",
            "        }",
            "    }",
            "",
            "    if(n != 1) result = result / n * (n - 1);",
            "    return result;",
            "}"
        ],
        "description": "numeric_prime_phiEuler"
    },
    "numeric_prime_primeFactorization": {
        "prefix": "numeric_prime_primeFactorization",
        "body": [
            "void primeFactorization(int n)",
            "{",
            "    cout << n << \" = \";",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        while(n % i == 0)",
            "        {",
            "            cout << i << \" \";",
            "            n /= i;",
            "        }",
            "    }",
            "",
            "    if(n != 1) cout << n;",
            "}"
        ],
        "description": "numeric_prime_primeFactorization"
    },
    "numeric_prime_segmentedSieve": {
        "prefix": "numeric_prime_segmentedSieve",
        "body": [
            "vector<bool> isPrime;",
            "vector<int> primes;",
            "",
            "void segmentedSieve(int l, int r, const vector<int>& basePrimes)",
            "{",
            "    isPrime.assign(r - l + 1, true);",
            "    for(int p : basePrimes)",
            "    {",
            "        int fr = ((l - 1) / p + 1) * p;",
            "        for(int j = fr; j <= r; j += p)",
            "            isPrime[j - l] = false;",
            "    }",
            "",
            "    for(int i = l; i <= r; i++)",
            "        if(isPrime[i - l]) primes.push_back(i);",
            "}"
        ],
        "description": "numeric_prime_segmentedSieve"
    },
    "numeric_prime_sieveOfEratosthenes": {
        "prefix": "numeric_prime_sieveOfEratosthenes",
        "body": [
            "vector<bool> isPrime;",
            "vector<int> primes;",
            "",
            "void sieveOfEratosthenes(int n)",
            "{",
            "    isPrime.assign(n + 1, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    for(int i = 2; i * i <= n; i++)",
            "        if(isPrime[i])",
            "        {",
            "            for(int j = i * i; j <= n; j += i)",
            "                isPrime[j] = false;",
            "        }",
            "",
            "    for(int i = 2; i<= n; i++)",
            "        if(isPrime[i]) primes.push_back(i);",
            "}"
        ],
        "description": "numeric_prime_sieveOfEratosthenes"
    },
    "template_gfg": {
        "prefix": "template_gfg",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "",
            "void solve()",
            "{",
            "",
            "}",
            "",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "",
            "    int t = 1;",
            "    cin >> t;",
            "",
            "    while(t--)",
            "        solve();",
            "",
            "    return 0;",
            "}"
        ],
        "description": "template_gfg"
    }
}