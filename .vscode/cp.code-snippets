{
	// Place your code workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"template": {
    	"prefix": "gfg",
    	"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;\n",
			"typedef long long ll;",
			"typedef pair<int, int> pii;\n",
			"void solve()",
			"{",
			"\t$0",
			"}",
			"",
			"int main()",
			"{",
				"\tios::sync_with_stdio(false);",
				"\tcin.tie(NULL);",
				"",
				"\tint t = 1;",
				"\tcin >> t;",
				"",
				"\twhile(t--)",
				"\t\tsolve();",
				"",
				"\treturn 0;",
          	"}"
        ],
        "description": "template"
    },
	"debug": {
    	"prefix": "debug",
    	"body": [
			"\nvoid __print(int x) {cerr << x;}",
			"void __print(long x) {cerr << x;}",
			"void __print(long long x) {cerr << x;}",
			"void __print(unsigned x) {cerr << x;}",
			"void __print(unsigned long x) {cerr << x;}",
			"void __print(unsigned long long x) {cerr << x;}",
			"void __print(float x) {cerr << x;}",
			"void __print(double x) {cerr << x;}",
			"void __print(long double x) {cerr << x;}",
			"void __print(char x) {cerr << '\\'' << x << '\\'';}",
			"void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
			"void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
			"void __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n",
			"template<typename T, typename V>",
			"void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}",
			"template<typename T>",
			"void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}",
			"void _print() {cerr << \"]\\n\";}",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",

			"#define dbg(...) cerr<<__func__<<\":\"<<__LINE__<<\" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__);\n",
        ],
        "description": "debug"
    },
	"orderSet": {
    	"prefix": "orderSet",
    	"body": [
			"\n#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
 			"typedef __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> ordered_set;\n",
        ],
        "description": "orderSet"
    },
	"bfs": {
    	"prefix": "bfs",
    	"body": [
			"\nvoid bfs(int s)",
			"{",
				"\tint sz = adj.size();",
				"\tpath.assign(sz, -1);",
				"\tvisited.assign(sz, false);",
				"\tqueue<int> q;",

				"\n\tq.push(s);",
				"\tvisited[s] = true;",

				"\n\tint u, v;",
				"\twhile(!q.empty())",
				"\t{",
					"\t\tu = q.front();",
					"\t\tq.pop();",

					"\t\tfor(int i = 0; i < (int)adj[u].size(); i++)",
					"\t\t{",
						"\t\t\tint v = adj[u][i];",
						"\t\t\tif(!visited[v])",
						"\t\t\t{",
							"\t\t\t\tvisited[v] = true;",
							"\t\t\t\tpath[v] = u;",
							"\t\t\t\tq.push(v);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "bfs"
    },
	"dfs_stack": {
    	"prefix": "dfs_stack",
    	"body": [
			"\nvoid dfs(int s)",
			"{",
				"\tint sz = adj.size();",
				"\tpath.assign(sz, -1);",
				"\tvisited.assign(sz, false);",
				"\tstack<int> st;",

				"\n\tst.push(s);",
				"\tvisited[s] = true;",

				"\n\tint u, v;",
				"\twhile(!st.empty())",
				"\t{",
					"\t\tu = st.top();",
					"\t\tst.pop();",

					"\t\tfor(int i = 0; i < (int)adj[u].size(); i++)",
					"\t\t{",
						"\t\t\tint v = adj[u][i];",
						"\t\t\tif(!visited[v])",
						"\t\t\t{",
							"\t\t\t\tvisited[v] = true;",
							"\t\t\t\tpath[v] = u;",
							"\t\t\t\tst.push(v);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "dfs with stack"
    },
	"dfs_recursive": {
    	"prefix": "dfs_recursive",
    	"body": [
			"\nvoid dfs(int s)",
			"{",
				"\tvisited[s] = true;",

				"\n\tfor(int i = 0; i < (int)adj[s].size(); i++)",
				"\t{",
					"\t\tint v = adj[s][i];",

					"\n\t\tif(!visited[v])",
					"\t\t{",
						"\t\t\tpath[v] = s;",
						"\t\t\tdfs(v);",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "dfs with recursive"
    },
	"dijkstra": {
    	"prefix": "dijkstra",
    	"body": [
			"\nvoid dijkstra(int s)",
			"{",
				"\tdist.assign(n, INF);",
				"\tpath.assign(n, -1);",
				"\tpriority_queue<pii, vector<pii>, greater<pii>> pq;",
				"\tpq.push({0, s});",
				"\tdist[s] = 0;",

				"\twhile(!pq.empty())",
				"\t{",
					"\t\tpii tmp = pq.top(); pq.pop();",

					"\t\tint u = tmp.second;",
					"\t\tif(tmp.first != dist[u]) continue;",

					"\t\tfor(int i = 0; i < (int)adj[u].size(); i++)",
					"\t\t{",
						"\t\t\tint v = adj[u][i].first;",
						"\t\t\tint w = adj[u][i].second;",
						"\t\t\tif(dist[v] > dist[u] + w)",
						"\t\t\t{",
							"\t\t\t\tdist[v] = dist[u] + w;",
							"\t\t\t\tpath[v] = u;",
							"\t\t\t\tpq.push({dist[v], v});",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "dijkstra"
    },
	"bellmanFord": {
    	"prefix": "bellmanFord",
    	"body": [
			"\nint bellmanFord(vector<Edge> &edges, int n, int m, int s)",
			"{",
				"\tdist.assign(n + 1, INF);",
				"\tpath.assign(n + 1, -1);",
				"\tdist[s] = 0;",

				"\tint u, v, w;",
				"\tfor(int i = 1; i < n; i++)",
				"\t{",
					"\t\tfor(int j = 0; j < m; j++)",
					"\t\t{",

						"\t\t\tu = edges[j].u;",
						"\t\t\tv = edges[j].v;",
						"\t\t\tw = edges[j].w;",
						"\t\t\tif(dist[u] != INF && dist[v] > dist[u] + w)",
						"\t\t\t{",
							"\t\t\t\tdist[v] = dist[u] + w;",
							"\t\t\t\tpath[v] = u;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tfor(int j = 0; j < m; j++)",
				"\t{",
					"\t\tu = edges[j].u;",
					"\t\tv = edges[j].v;",
					"\t\tw = edges[j].w;",
					"\t\tif(dist[u] != INF && dist[v] > dist[u] + w)",
					"\t\t{",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",

				"\treturn true;",
			"}",
        ],
        "description": "bellmanFord"
    },
	"floydWarshall": {
    	"prefix": "floydWarshall",
    	"body": [
			"\nint floydWarshall(vector<vector<int>> &matrix, int n)",
			"{",
				"\tdist.assign(n + 1, vector<int>(n + 1));",
				"\tpath.assign(n + 1, vector<int>(n + 1));",

				"\tfor(int i = 1; i <= n; i++)",
				"\t{",
					"\t\tfor(int j = 1; j <= n; j++)",
					"\t\t{",

						"\t\t\tdist[i][j] = i == j ? 0 : matrix[i][j];",
						"\t\t\tif(i != j && dist[i][j] < INF)",
						"\t\t\t{",
							"\t\t\t\tpath[i][j] = i;",
						"\t\t\t}",
						"\t\t\telse",
						"\t\t\t{",
							"\t\t\t\tpath[i][j] = -1;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tfor(int k = 1; k <= n; k++)",
				"\t{",
					"\t\tfor(int i = 1; i <= n; i++)",
					"\t\t{",

						"\t\t\tif(dist[i][k] >= INF) continue;",
						"\t\t\tfor(int j = 1; j <= n; j++)",
						"\t\t\t{",
							"\t\t\t\tif(dist[k][j] < INF && dist[i][j] > dist[i][k] + dist[k][j])",
							"\t\t\t\t{",
								"\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];",
								"\t\t\t\t\tpath[i][j] = path[k][j];",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",

				"\t// check negative cycle",
				"\tfor(int i = 1; i <= n; i++)",
				"\t{",
					"\t\tif(dist[i][j] < 0) return false;",
				"\t}",
			"}",
        ],
        "description": "floydWarshall"
    },
	"Edge": {
    	"prefix": "Edge",
    	"body": [
			"\nstruct Edge",
			"{",
				"\tint u, v, w;",
				"\tEdge(int u = 0, int v = 0, int w = 0)",
					"\t\t: u(u), v(v), w(w) {}",
			"};",
        ],
        "description": "Edge"
    },
	"DisjointSet": {
    	"prefix": "DisjointSet",
    	"body": [
			"\nstruct DisjointSet",
			"{",
				"\tvector<int> parent, Rank;",
				"\tDisjointSet(int n): parent(n + 1), Rank(n + 1, 0)",
				"\t{",
					"\t\tfor (int i=1; i<=n; i++) parent[i] = i;",
				"\t}",
				"\tint findSet(int u)",
				"\t{",
					"\t\tif (parent[u] != u) parent[u] = findSet(parent[u]);",
					"\t\treturn parent[u];",
				"\t}",
				"\tbool unionSet(int u, int v)",
				"\t{",
					"\t\tint pu = findSet(u), int pv = findSet(v);",
					"\t\tif(pu == pv) return false;",
					"\t\tif(Rank[pu] > Rank[pv]) parent[pv] = pu;",
					"\t\telse if(Rank[pu] < Rank[pv]) parent[pu] = pv;",
					"\t\telse",
					"\t\t{",
						"\t\t\tparent[pv] = pu;",
						"\t\t\tRank[pu]++;",
					"\t\t}",
					"\t\treturn true;",
				"\t}",
			"};",
        ],
        "description": "DisjointSet"
    },
}