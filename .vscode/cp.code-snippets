{
    "brute_backtracking": {
        "prefix": "brute_backtracking",
        "body": [
            "void backtracking(vector<int>& curState, int i, int sum)",
            "{",
            "    if(best_length == curState.size())",
            "    {",
            "        return;",
            "    }",
            "    if(i == n)",
            "    {",
            "        best = curState;",
            "        best_length = best.size();",
            "        return;",
            "    }",
            "    for(int j = 0; j < i; j++)",
            "    {",
            "        curState.push_back(a[j]);",
            "        backtracking(curState, j + 1, sum + a[j]);",
            "        curState.pop_back();",
            "    }",
            "}"
        ],
        "description": "brute_backtracking"
    },
    "data_dsu": {
        "prefix": "data_dsu",
        "body": [
            "struct DisjointSet",
            "{",
            "    vector<int> parent, Rank;",
            "",
            "    DisjointSet(int n) : parent(n + 1), Rank(n + 1, 0)",
            "    {",
            "        for (int i = 1; i <= n; i++)",
            "            parent[i] = i;",
            "    }",
            "",
            "    int findSet(int u)",
            "    {",
            "        if (parent[u] != u)",
            "            parent[u] = findSet(parent[u]);",
            "        return parent[u];",
            "    }",
            "",
            "    bool unionSet(int u, int v)",
            "    {",
            "        int pu = findSet(u), pv = findSet(v);",
            "        if (pu == pv)",
            "            return false;",
            "        if (Rank[pu] > Rank[pv])",
            "            parent[pv] = pu;",
            "        else if (Rank[pu] < Rank[pv])",
            "            parent[pu] = pv;",
            "        else",
            "        {",
            "            parent[pv] = pu;",
            "            Rank[pu]++;",
            "        }",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "data_dsu"
    },
    "data_indexedSet": {
        "prefix": "data_indexedSet",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template<typename T>",
            "using indexed_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;"
        ],
        "description": "data_indexedSet"
    },
    "data_FenwickTree_point_range": {
        "prefix": "data_FenwickTree_point_range",
        "body": [
            "template <class T>",
            "struct FenwickTree",
            "{",
            "    int n;",
            "    vector<T> f;",
            "",
            "    FenwickTree(int n_)",
            "    {",
            "        n = n_;",
            "        f.assign(n + 7, 0);",
            "    }",
            "",
            "    void update(int id, int val)",
            "    {",
            "        while (id <= n)",
            "        {",
            "            f[id] += val;",
            "            id += id & -id;",
            "        }",
            "    }",
            "",
            "    T getSum(int id)",
            "    {",
            "        T sum = 0;",
            "        while (id > 0)",
            "        {",
            "            sum += f[id];",
            "            id -= id & -id;",
            "        }",
            "        return sum;",
            "    }",
            "",
            "    T sumRange(int l, int r)",
            "    {",
            "        return getSum(r) - getSum(l);",
            "    }",
            "",
            "    void updateRange(int l, int r, T val)",
            "    {",
            "        update(l, val);",
            "        update(r + 1, -val);",
            "    }",
            "};"
        ],
        "description": "data_FenwickTree_point_range"
    },
    "data_FenwickTree_range_range": {
        "prefix": "data_FenwickTree_range_range",
        "body": [
            "// @brief This Fenwick tree manages from 1 index",
            "template <class T>",
            "struct FenwickTree",
            "{",
            "    int n;",
            "    vector<T> f1, f2;",
            "",
            "    FenwickTree(int n_)",
            "    {",
            "        n = n_;",
            "        f1.assign(n + 7, 0);",
            "        f2.assign(n + 7, 0);",
            "    }",
            "",
            "    void update(vector<T> &f, int id, int val)",
            "    {",
            "        while (id <= n)",
            "        {",
            "            f[id] += val;",
            "            id += id & -id;",
            "        }",
            "    }",
            "",
            "    T getSum(vector<T> &f, int id)",
            "    {",
            "        T sum = 0;",
            "        while (id > 0)",
            "        {",
            "            sum += f[id];",
            "            id -= id & -id;",
            "        }",
            "        return sum;",
            "    }",
            "",
            "    void updateRange(int l, int r, T val)",
            "    {",
            "        update(f1, l, val);",
            "        update(f1, r + 1, -val);",
            "        update(f2, l, val * (l - 1));",
            "        update(f2, r + 1, -val * r);",
            "    }",
            "",
            "    T prefixSum(int id)",
            "    {",
            "        return getSum(f1, id) * id - getSum(f2, id);",
            "    }",
            "",
            "    T sumRange(int l, int r)",
            "    {",
            "        return prefixSum(r) - prefixSum(l - 1);",
            "    }",
            "};"
        ],
        "description": "data_FenwickTree_range_range"
    },
    "data_segTree_lazy": {
        "prefix": "data_segTree_lazy",
        "body": [
            "template <class T>",
            "struct LazySegTree",
            "{",
            "    vector<T> seg, lazy;",
            "    int n;",
            "",
            "    LazySegTree(int n_)",
            "    {",
            "        n = n_;",
            "        seg.assign(4 * n, 0);",
            "        lazy.assign(4 * n, 0);",
            "    }",
            "",
            "    LazySegTree(const vector<T> &a) : LazySegTree((int)a.size())",
            "    {",
            "        buildTree(a, 0, 0, n - 1);",
            "    }",
            "",
            "    void buildTree(const vector<T> &a, int id, int l, int r)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        buildTree(a, 2 * id + 1, l, m);",
            "        buildTree(a, 2 * id + 2, m + 1, r);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    void down(int id, int l, int r)",
            "    {",
            "        if (l != r)",
            "        {",
            "            lazy[2 * id + 1] += lazy[id];",
            "            lazy[2 * id + 2] += lazy[id];",
            "        }",
            "        seg[id] += lazy[id];",
            "        lazy[id] = 0;",
            "    }",
            "",
            "    void lazyUpdate(int id, int l, int r, int fr, int to, T val)",
            "    {",
            "        if (lazy[id] != 0)",
            "            down(id, l, r);",
            "        if (fr > r || to < l)",
            "            return;",
            "        if (fr <= l && r <= to)",
            "        {",
            "            seg[id] += val;",
            "            if (l != r)",
            "            {",
            "                lazy[2 * id + 1] += val;",
            "                lazy[2 * id + 2] += val;",
            "            }",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        lazyUpdate(2 * id + 1, l, m, fr, to, val);",
            "        lazyUpdate(2 * id + 2, m + 1, r, fr, to, val);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    T lazyMinQuery(int id, int l, int r, int fr, int to)",
            "    {",
            "        if (lazy[id] != 0)",
            "            down(id, l, r);",
            "        if (fr > r || to < l)",
            "            return INT_MAX;",
            "        if (fr <= l && r <= to)",
            "            return seg[id];",
            "",
            "        int m = (l + r) / 2;",
            "",
            "        return min(",
            "            lazyMinQuery(2 * id + 1, l, m, fr, to),",
            "            lazyMinQuery(2 * id + 2, m + 1, r, fr, to));",
            "    }",
            "};"
        ],
        "description": "data_segTree_lazy"
    },
    "data_segTree_nomal": {
        "prefix": "data_segTree_nomal",
        "body": [
            "template <class T>",
            "struct SegTree",
            "{",
            "    vector<T> seg;",
            "    int n;",
            "",
            "    SegTree(int n_)",
            "    {",
            "        n = n_;",
            "        seg.assign(4 * n, 0);",
            "    }",
            "",
            "    SegTree(const vector<T> &a) : SegTree((int)a.size())",
            "    {",
            "        buildTree(a, 0, 0, n - 1);",
            "    }",
            "",
            "    void buildTree(const vector<T> &a, int id, int l, int r)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        buildTree(a, 2 * id + 1, l, m);",
            "        buildTree(a, 2 * id + 2, m + 1, r);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    T queryMin(int id, int l, int r, int fr, int to)",
            "    {",
            "        if (fr <= l && r <= to)",
            "            return seg[id];",
            "        if (fr > r || to < l)",
            "            return INT_MAX;",
            "",
            "        int m = (l + r) / 2;",
            "",
            "        return min(",
            "            queryMin(2 * id + 1, l, m, fr, to),",
            "            queryMin(2 * id + 2, m + 1, r, fr, to));",
            "    }",
            "",
            "    void updateMin(int id, int l, int r, int pos, T val)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = val;",
            "            return;",
            "        }",
            "",
            "        int m = (l + r) / 2;",
            "        if (pos <= m)",
            "            updateMin(2 * id + 1, l, m, pos, val);",
            "        else",
            "            updateMin(2 * id + 2, m + 1, r, pos, val);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "};"
        ],
        "description": "data_segTree_nomal"
    },
    "data_SparseTable_rmq": {
        "prefix": "data_SparseTable_rmq",
        "body": [
            "template <class T>",
            "struct SparseTable",
            "{",
            "    int level, n; // 2^MAX_LOG >= n",
            "    vector<vector<T>> f;",
            "    vector<T> log_2;",
            "",
            "    SparseTable(int n_)",
            "    {",
            "        n = n_;",
            "        level = ceil(log2(n));",
            "        f.assign(n, vector<T>(level + 1, 0));",
            "        log_2.assign(n_log + 1, 0);",
            "    }",
            "",
            "    void compute_spare_table(const vector<T> &a)",
            "    {",
            "        for (int i = 0; i < n; i++)",
            "            f[i][0] = a[i];",
            "",
            "        for (int j = 1; (1 << j) <= n; j++)",
            "        {",
            "            int step = 1 << (j - 1);",
            "            for (int i = 0; i + 2 * step <= n; i++)",
            "            {",
            "                f[i][j] = min(f[i][j - 1], f[i + step][j - 1]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T minQuery(int l, int r)",
            "    {",
            "        int k = log_2[r - l + 1];",
            "        return min(f[l][k], f[r - (1 << k) + 1][k]);",
            "    }",
            "",
            "    void compute_log()",
            "    {",
            "        log_2[1] = 0;",
            "        for (int i = 2; i <= n; i++)",
            "        {",
            "            log_2[i] = log_2[i / 2] + 1;",
            "        }",
            "    }",
            "};"
        ],
        "description": "data_SparseTable_rmq"
    },
    "data_SparseTable_rsq": {
        "prefix": "data_SparseTable_rsq",
        "body": [
            "template <class T>",
            "struct SparseTable",
            "{",
            "    int level, n; // 2^MAX_LOG >= n",
            "    vector<vector<T>> f;",
            "    vector<T> log_2;",
            "",
            "    SparseTable(int n_)",
            "    {",
            "        n = n_;",
            "        level = ceil(log2(n));",
            "        f.assign(n, vector<T>(level + 1, 0));",
            "        log_2.assign(n_log + 1, 0);",
            "    }",
            "",
            "    void compute_spare_table(const vector<T> &a)",
            "    {",
            "        for (int i = 0; i < n; i++)",
            "            f[i][0] = a[i];",
            "",
            "        for (int j = 1; (1 << j) <= n; j++)",
            "        {",
            "            int step = 1 << (j - 1);",
            "            for (int i = 0; i + 2 * step <= n; i++)",
            "            {",
            "                f[i][j] = f[i][j - 1] + f[i + step][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    T sumQuery(int l, int r)",
            "    {",
            "        int k, total = 0;",
            "        for (int k = n_log; k >= 0; k--)",
            "        {",
            "            if (l + (1 << k) - 1 <= r)",
            "            {",
            "                total += f[l][k];",
            "                l += 1 << k;",
            "            }",
            "        }",
            "        return total;",
            "    }",
            "",
            "    void compute_log()",
            "    {",
            "        log_2[1] = 0;",
            "        for (int i = 2; i <= n; i++)",
            "        {",
            "            log_2[i] = log_2[i / 2] + 1;",
            "        }",
            "    }",
            "};"
        ],
        "description": "data_SparseTable_rsq"
    },
    "divideConquer_closestPairPoints": {
        "prefix": "divideConquer_closestPairPoints",
        "body": [
            "const int INF = 1e9;",
            "",
            "struct Point",
            "{",
            "    int x, y;",
            "    Point(int x = 0, int y = 0) : x(x), y(y){}",
            "};",
            "",
            "int xCompare(const Point& p1, const Point& p2)",
            "{",
            "    return p1.x < p2.x;",
            "}",
            "",
            "int yCompare(const Point& p1, const Point& p2)",
            "{",
            "    return p1.y < p2.y;",
            "}",
            "",
            "double dist(Point p1, Point p2)",
            "{",
            "    double dx = 1.0 * (p1.x - p2.x) * (p1.x - p2.x);",
            "    double dy = 1.0 * (p1.y - p2.y) * (p1.y - p2.y);",
            "    return sqrt(dx + dy);",
            "}",
            "",
            "double stripClosest(vector<Point> points, int n, double d)",
            "{",
            "    double res = d;",
            "    sort(points.begin(), points.end(), yCompare);",
            "    for(int i = 0; i < n; i++)",
            "        for(int j = i + 1; j < n && points[j].y - points[i].y <= res; j++)",
            "        {",
            "            res = min(res, dist(points[i], points[j]));",
            "        }",
            "    return res;",
            "}",
            "",
            "double closestPair(vector<Point>& points, int left, int right)",
            "{",
            "    if(left >= right) return INF;",
            "    if(right - left == 1) return dist(points[left], points[right]);",
            "",
            "    int mid = (left + right) / 2;",
            "    Point pMid = points[mid];",
            "    double minLeft = closestPair(points, left, mid);",
            "    double minRight = closestPair(points, mid + 1, right);",
            "    double res = min(minLeft, minRight);",
            "",
            "    vector<Point> strip;",
            "    for(int i = left; i <= right; i++)",
            "        if(abs(points[i].x - pMid.x) <= res)",
            "            strip.push_back(points[i]);",
            "",
            "    res = min(res, stripClosest(strip, strip.size(), res));",
            "    return res;",
            "}",
            "",
            "void test()",
            "{",
            "    int n; cin >> n;",
            "    vector<Point> points(n);",
            "    for(int i = 0; i < n; i++) cin >> points[i].x >> points[i].y;",
            "",
            "    sort(points.begin(), points.end(), xCompare);",
            "    double res = closestPair(points, 0, n - 1);",
            "    cout << res << \"\\n\";",
            "",
            "    return 0;",
            "}"
        ],
        "description": "divideConquer_closestPairPoints"
    },
    "divideConquer_countInversions": {
        "prefix": "divideConquer_countInversions",
        "body": [
            "int merge(vector<int> &a, int l, int m, int r)",
            "{",
            "    vector<int> b(a.begin() + l, a.begin() + m + 1);",
            "    vector<int> c(a.begin() + m + 1, a.begin() + r + 1);",
            "    int nB = m - l + 1, nC = r - m;",
            "    int i = 0, j = 0, k = l;",
            "    while(i < nB && j < nC)",
            "    {",
            "        if(b[i] > c[j])",
            "        {",
            "            a[k++] = c[j++];",
            "        }",
            "        else",
            "        {",
            "            a[k++] = b[i++];",
            "            cnt += j;",
            "        }",
            "    }",
            "    while(i < nB)",
            "    {",
            "        a[k++] = b[i++];",
            "        cnt += j;",
            "    }",
            "    while(j < nC)",
            "    {",
            "        a[k++] = c[j++];",
            "    }",
            "    return cnt;",
            "}",
            "",
            "int countInversions(vector<int> &a, int l, int r)",
            "{",
            "    if(l >= r) return 0;",
            "    int m = (l + r) / 2;",
            "    // Chia va tri",
            "    int countLeft = countInversions(a, l, m);",
            "    int countRight = countInversions(a, m + 1, r);",
            "    // Gop",
            "    int countMid = merge(a, l, m, r);",
            "    return countLeft + countRight + countMid;",
            "}"
        ],
        "description": "divideConquer_countInversions"
    },
    "dynamic_coinChange": {
        "prefix": "dynamic_coinChange",
        "body": [
            "int coinChange(vector<int> &coins, int n, int w)",
            "{",
            "    dp[0] = 0;",
            "    for(int i = 1; i <= w; i++)",
            "        dp[i] = INF;",
            "",
            "    for(int i = 1; i <= n; i++)",
            "        for(int j = coins[i - 1]; j <= w; j++)",
            "            dp[j] = min(dp[j], dp[j - coins[i - 1]] + 1);",
            "",
            "    return dp[w];",
            "}",
            "",
            "void trace(vector<int> &coins, int n, int w)",
            "{",
            "    while(w > 0)",
            "    {",
            "        if(w >= coins[n - 1] && dp[w] == dp[w - coins[n - 1]] + 1)",
            "        {",
            "            cout << coins[n - 1] << \" \";",
            "            w -= coins[n - 1];",
            "        }",
            "        else",
            "            n -= 1;",
            "    }",
            "}"
        ],
        "description": "dynamic_coinChange"
    },
    "dynamic_lcs": {
        "prefix": "dynamic_lcs",
        "body": [
            "int lcs(vector<int> &a, vector<int> &b)",
            "{",
            "    int n = a.size();",
            "    int m = b.size();",
            "",
            "    for (int i = 0; i <= n; i++)",
            "        dp[i][0] = 0;",
            "    for (int j = 0; j <= m; j++)",
            "        dp[0][j] = 0;",
            "",
            "    for (int i = 1; i <= n; i++)",
            "        for (int j = 1; j <= m; j++)",
            "            if (a[i - 1] == b[j - 1])",
            "                dp[i][j] = dp[i - 1][j - 1] + 1;",
            "            else",
            "                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);",
            "",
            "    return dp[n][m];",
            "}",
            "",
            "void trace(vector<int>& a, vector<int>& b)",
            "{",
            "    int n = a.size(), m = b.size();",
            "",
            "    vector<int> res;",
            "    while(n > 0 && m > 0)",
            "    {",
            "        if(a[n - 1] == b[m - 1])",
            "        {",
            "            res.push_back(a[n - 1]);",
            "            n--;",
            "            m--;",
            "        }",
            "        else if(dp[n - 1][m] > dp[n][m - 1])",
            "            n--;",
            "        else",
            "            m--;",
            "    }",
            "    for(int i = res.size() - 1; i >= 0; i++)",
            "        cout << res[i] << \" \";",
            "}"
        ],
        "description": "dynamic_lcs"
    },
    "dynamic_lis": {
        "prefix": "dynamic_lis",
        "body": [
            "int LIS(vector<int>& A, vector<int>& dp, vector<int> & prev)",
            "{",
            "    int n = A.size();",
            "    vector<int> lis, lis_index;",
            "    dp.assign(n, 1);",
            "    prev.assign(n, -1);",
            "",
            "    for(int j, i = 0; i < n; i++)",
            "    {",
            "        j = upper_bound(lis.begin(), lis.end(), A[i]) - lis.begin();",
            "        dp[i] = j + 1;",
            "        if(j != 0)",
            "        {",
            "            prev[i] = lis_index[j - 1];",
            "        }",
            "        if(j == (int)lis.size())",
            "        {",
            "            lis.push_back(A[i]);",
            "            lis_index.push_back(i);",
            "        }",
            "        else",
            "        {",
            "            lis[j] = A[i];",
            "            lis_index[j] = i;",
            "        }",
            "    }",
            "",
            "    return lis_index[(int)lis.size() - 1];",
            "}",
            "",
            "void trace(vector<int>& A, vector<int>& prev, int pos)",
            "{",
            "    vector<int> b;",
            "    while(pos != -1)",
            "    {",
            "        b.push_back(A[pos]);",
            "        pos = prev[pos];",
            "    }",
            "",
            "    for(int i = (int)b.size() - 1; i >= 0; i--)",
            "        cout << b[i] << ' ';",
            "    cout << '\\n';",
            "}",
            "",
            "void test()",
            "{",
            "    int n; cin >> n;",
            "",
            "    vector<int> A(n);",
            "    for(int i = 0; i < n; i++)",
            "        cin >> A[i];",
            "",
            "    vector<int> dp, prev;",
            "    int pos = LIS(A, dp, prev);",
            "",
            "    cout << \"LIS: \" << dp[pos] << \"\\n\";",
            "    trace(A, prev, pos);",
            "}"
        ],
        "description": "dynamic_lis"
    },
    "dynamic_knapsack_nSpace": {
        "prefix": "dynamic_knapsack_nSpace",
        "body": [
            "int knapsack(int N, int W)",
            "{",
            "    dp.assign(W + 1, 0);",
            "",
            "    for(int i = 0; i < N; i++)",
            "        for(int j = W; j >= weight[i]; j--)",
            "        {",
            "            if(dp[j] < dp[j - weight[i]] + profit[i])",
            "                dp[j] = dp[j - weight[i]] + profit[i];",
            "        }",
            "",
            "    return dp[W];",
            "}"
        ],
        "description": "dynamic_knapsack_nSpace"
    },
    "dynamic_knapsack_nwSpace": {
        "prefix": "dynamic_knapsack_nwSpace",
        "body": [
            "vector<int> weight, profit;",
            "vector<vector<int>> dp;",
            "",
            "int knapsack(int N, int W)",
            "{",
            "    dp.assign(N + 1, vector<int>(W + 1, 0));",
            "",
            "    for (int j = 0; j <= W; j++)",
            "        dp[0][j] = 0;",
            "",
            "    for (int i = 1; i <= N; i++)",
            "        for (int j = 0; j <= W; j++)",
            "        {",
            "            dp[i][j] = dp[i - 1][j];",
            "            if (j >= weight[i - 1] && dp[i][j] < dp[i - 1][j - weight[i - 1]] + profit[i - 1])",
            "            {",
            "                dp[i][j] = dp[i - 1][j - weight[i - 1]] + profit[i - 1];",
            "            }",
            "        }",
            "",
            "    return dp[N][W];",
            "}",
            "",
            "void trace(int N, int W)",
            "{",
            "    int totalWeight = 0, totalProfit = 0;",
            "    while (N > 0 && W > 0)",
            "    {",
            "        if (weight[N - 1] <= W && dp[N][W] == dp[N - 1][W - weight[N - 1]] + profit[N - 1])",
            "        {",
            "            cout << weight[N - 1] << \" - \" << profit[N - 1] << \"\\n\";",
            "            totalWeight += weight[N - 1];",
            "            totalProfit += profit[N - 1];",
            "            W -= weight[N - 1];",
            "        }",
            "        N--;",
            "    }",
            "    cout << \"Total weight: \" << totalWeight << \"\\n\";",
            "    cout << \"Total profit: \" << totalProfit << \"\\n\";",
            "}",
            "",
            "void test()",
            "{",
            "    int n, w; cin >> n >> w;",
            "    weight.resize(n);",
            "    profit.resize(n);",
            "    for(int i = 0; i < n; i++)",
            "        cin >> weight[i] >> profit[i];",
            "",
            "    knapsack(n, w);",
            "    trace(n, w);",
            "}"
        ],
        "description": "dynamic_knapsack_nwSpace"
    },
    "geometry_circle": {
        "prefix": "geometry_circle",
        "body": [
            "struct Circle : Point",
            "{",
            "    double r;",
            "",
            "    Circle(double x = 0, double y = 0, double r = 0) : Point(x, y), r(r) {}",
            "",
            "    Circle(Point p, double r) : Point(p), r(r) {}",
            "",
            "    bool contains(Point p)",
            "    {",
            "        return (*this - p).len() <= r + EPS;",
            "    }",
            "};",
            "",
            "vector<Point> intersection(Line l, Circle cir)",
            "{",
            "    double r = cir.r;",
            "    double a = l.a, b = l.b, c = l.c + l.a * cir.x + l.b * cir.y;",
            "    vector<Point> res;",
            "",
            "    double x0 = -a * c / (a * a + b * b);",
            "    double y0 = -b * c / (a * a + b * b);",
            "",
            "    if(c * c > r * r * (a * a + b * b) + EPS)",
            "        return res;",
            "    else if(fabs(c * c - r * r (a * a + b * b)) < EPS)",
            "    {",
            "        res.push_back(Point(x0, y0) + Point(cir.x, cir.y));",
            "        return res;",
            "    }",
            "",
            "    double d = c * c - r * r (a * a + b * b);",
            "    double mult = sqrt(d / (a * a + b * b));",
            "    double ax, ay, bx, by;",
            "    ax = x0 + b * mult;",
            "    bx = x0 - b * mult;",
            "    ay = y0 - a * mult;",
            "    by = y0 + a * mult;",
            "",
            "    res.push_back(Point(ax, ay) + Point(cir.x, cir.y));",
            "    res.push_back(Point(bx, by) + Point(cir.x, cir.y));",
            "    return res;",
            "}"
        ],
        "description": "geometry_circle"
    },
    "geometry_line": {
        "prefix": "geometry_line",
        "body": [
            "struct Line",
            "{",
            "    double a, b, c;",
            "    Point A, B;",
            "",
            "    Line(double a, double b, double c) : a(a), b(b), c(c) {}",
            "",
            "    Line(Point A, Point B) : A(A), B(B)",
            "    {",
            "        a = B.y - A.y;",
            "        b = A.x - B.x;",
            "        c = -(a * A.x + b * A.y);",
            "    }",
            "",
            "    Line(Point P, double k)",
            "    {",
            "        a = -k;",
            "        b = 1;",
            "        c = k * P.x - P.y;",
            "    }",
            "",
            "    double f(Point A)",
            "    {",
            "        return a * A.x + b * A.y;",
            "    }",
            "};",
            "",
            "bool areParallel(Line l1, Line l2)",
            "{",
            "    return cmp(l1.a * l2.b, l1.b * l2.a) == 0;",
            "}",
            "",
            "bool areSame(Line l1, Line l2)",
            "{",
            "    return areParallel(l1, l2) && cmp(l1.c * l2.a, l2.c * l1.a) == 0 && cmp(l1.c * l2.b, l1.b *l2.c) == 0;",
            "}",
            "",
            "bool areIntersect(Line l1, Line l2, Point &p)",
            "{",
            "    if(areParallel(l1, l2)) return false;",
            "    double dx = l1.b * l2.c - l2.b * l1.c;",
            "    double dy = l1.c * l2.a - l2.c * l1.a;",
            "    double d = l1.a * l2.b - l2.a * l1.b;",
            "    p = Point(dx / d, dy / d);",
            "    return true;",
            "}",
            "",
            "double distToLine(Point p, Point a, Point b, Point &c)",
            "{",
            "    Point ap = p - a, ab = b - a;",
            "    double k = ap.dot(ab) / ab.norm();",
            "    c = a + (ab * k);",
            "    return (p - c).len();",
            "}"
        ],
        "description": "geometry_line"
    },
    "geometry_point": {
        "prefix": "geometry_point",
        "body": [
            "const double EPS = 1e-9;",
            "",
            "int cmp(double x, double y)",
            "{",
            "    if(x < y - EPS)",
            "        return -1;",
            "    else if(x > y + EPS)",
            "        return 1;",
            "    else return 0;",
            "}",
            "",
            "struct Point",
            "{",
            "    double x, y;",
            "",
            "    Point(double _x = 0, double _y = 0) : x(_x), y(_y) {}",
            "",
            "    int p_compare(const Point& q) const",
            "    {",
            "        if(cmp(x, q.x) != 0) return cmp(x, q.x);",
            "        return cmp(y, q.y);",
            "    }",
            "",
            "    bool operator>(const Point& q) const { return p_compare(q) > 0; }",
            "    bool operator<(const Point& q) const { return p_compare(q) < 0; }",
            "    bool operator==(const Point& q) const { return p_compare(q) == 0; }",
            "    bool operator>=(const Point& q) const { return p_compare(q) >= 0; }",
            "    bool operator<=(const Point& q) const { return p_compare(q) <= 0; }",
            "    bool operator!=(const Point& q) const { return p_compare(q) != 0; }",
            "",
            "    Point operator+(const Point& q) const",
            "    {",
            "        return Point(x + q.x, y + q.y);",
            "    }",
            "",
            "    Point operator-(const Point& q) const",
            "    {",
            "        return Point(x - q.x, y - q.y);",
            "    }",
            "",
            "    Point operator*(double k) const",
            "    {",
            "        return Point(x * k, y * k);",
            "    }",
            "",
            "    Point operator/(double k) const",
            "    {",
            "        return Point(x / k, y / k);",
            "    }",
            "",
            "    double dot(const Point& q) const",
            "    {",
            "        return x * q.x + y * q.y;",
            "    }",
            "",
            "    double cross(const Point& q) const",
            "    {",
            "        return x * q.y - y * q.x;",
            "    }",
            "",
            "    double norm()",
            "    {",
            "        return x * x + y * y;",
            "    }",
            "",
            "    double len()",
            "    {",
            "        return sqrt(norm());",
            "    }",
            "",
            "    Point rotate(double alpha)",
            "    {",
            "        double cosa = cos(alpha), sina = sin(alpha);",
            "        return Point(x * cosa - y * sina, x * sina + y * cosa);",
            "    }",
            "};"
        ],
        "description": "geometry_point"
    },
    "geometry_polygon": {
        "prefix": "geometry_polygon",
        "body": [
            "using Polygon = vector<Point>;",
            "",
            "double signedArea(const Polygon& p)",
            "{",
            "    double area = 0;",
            "    for(int j, i = 0; i < (int)p.size(); i++)",
            "    {",
            "        j = (i + 1) % (int)p.size();",
            "        area += p[i].cross(p[j]);",
            "    }",
            "    return area / 2.0;",
            "}",
            "",
            "double area(const Polygon& p)",
            "{",
            "    return fabs(signedArea(p));",
            "}",
            "",
            "int ccw(Point a, Point b, Point c)",
            "{",
            "    return cmp((b - a).cross(c - a), 0);",
            "}",
            "",
            "// note: Assume there are no 3 collinear points",
            "bool isConvex(const Polygon& p)",
            "{",
            "    int sz = p.size();",
            "    if(sz < 3) return false;",
            "    int turn = ccw(p[0], p[1], p[2]);",
            "    for(int i = 1; i < sz; i++)",
            "        if(ccw(p[i], p[(i + 1) % sz], p[(i + 2) % sz]) * turn < 0)",
            "            return false;",
            "    return true;",
            "}",
            "",
            "Point pivot;",
            "",
            "bool compare(const Point& p, const Point& q)",
            "{",
            "    int tmp = ccw(pivot, p, q);",
            "    if(tmp > 0) return true;",
            "    return (tmp == 0 && (p - pivot).norm() < (q - pivot).norm());",
            "}"
        ],
        "description": "geometry_polygon"
    },
    "geometry_rectangle": {
        "prefix": "geometry_rectangle",
        "body": [
            "struct Rect {",
            "\tint x1, y1, x2, y2;",
            "\tint area() { return (y2 - y1) * (x2 - x1); }",
            "};",
            "",
            "int intersect(Rect p, Rect q) {",
            "\tint xOverlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1));",
            "\tint yOverlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1));",
            "\treturn xOverlap * yOverlap;",
            "}"
        ],
        "description": "geometry_rectangle"
    },
    "geometry_convexHull_grahamScan": {
        "prefix": "geometry_convexHull_grahamScan",
        "body": [
            "void convexHull(Polygon& pts)",
            "{",
            "    pivot = pts[0];",
            "    for(int i = 1; i < (int)pts.size(); i++)",
            "        if(cmp(pivot.y, pts[i].y) > 0 || (cmp(pivot.y, pts[i].y) == 0 && cmp(pivot.x, pts[i].x) > 0))",
            "            pivot = pts[i];",
            "",
            "    sort(pts.begin(), pts.end(), compare);",
            "    // remove duplicate points",
            "    pts.erase(unique(pts.begin(), pts.end()), pts.end());",
            "    if(pts.size() < 3) return;",
            "",
            "    int n = 0;",
            "    for(int i = 0; i < (int)pts.size(); i++)",
            "    {",
            "        while(n > 1 && ccw(pts[n - 2], pts[n - 1], pts[i]) <= 0) n--;",
            "        pts[n++] = pts[i];",
            "    }",
            "    pts.resize(n);",
            "}"
        ],
        "description": "geometry_convexHull_grahamScan"
    },
    "geometry_convexHull_monotoneChain": {
        "prefix": "geometry_convexHull_monotoneChain",
        "body": [
            "void convexHull(Polygon &pts)",
            "{",
            "    sort(pts.begin(), pts.end());",
            "    pts.erase(unique(pts.begin(), pts.end()), pts.end());",
            "",
            "    Polygon up, down;",
            "    int n = 0, m = 0;",
            "    for (int i = 0; i < (int)pts.size(); i++)",
            "    {",
            "        while (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], pts[i]) >= 0)",
            "            up.pop_back();",
            "        up.push_back(pts[i]);",
            "",
            "        while (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], pts[i]) <= 0)",
            "            down.pop_back();",
            "        down.push_back(pts[i]);",
            "    }",
            "    pts = down;",
            "    for (int i = up.size() - 2; i > 0; i--)",
            "        pts.push_back(up[i]);",
            "}"
        ],
        "description": "geometry_convexHull_monotoneChain"
    },
    "graph_hld": {
        "prefix": "graph_hld",
        "body": [
            "vector<int> parent;",
            "vector<vector<int>> graph;",
            "vector<int> in, out;",
            "vector<int> top;",
            "vector<int> order;",
            "vector<int> sz;",
            "int dfs_num;",
            "int n;",
            "",
            "void dfs_size(int u, int p = -1)",
            "{",
            "    parent[u] = p;",
            "    sz[u] = 1;",
            "",
            "    for(int i = 0; i < (int)graph[u].size(); i++)",
            "    {",
            "        if(graph[u][i] == p) continue;",
            "        dfs_size(graph[u][i], u);",
            "        sz[u] += sz[graph[u][i]];",
            "        if (sz[graph[u][i]] > sz[graph[u][0]])",
            "            swap(graph[u][i], graph[u][0]);",
            "    }",
            "}",
            "",
            "void dfs_hld(int u, int p = -1)",
            "{",
            "    in[u] = ++dfs_num;",
            "    order[dfs_num] = u;",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(v == p) continue;",
            "        top[v] = (v == graph[u][0]) ? top[u] : v;",
            "        dfs_hld(v, u);",
            "    }",
            "",
            "    out[u] = dfs_num;",
            "}",
            "",
            "void hld(int root)",
            "{",
            "    dfs_num = -1;",
            "    in.assign(n + 1, -1);",
            "    out.assign(n + 1, -1);",
            "    top.assign(n + 1, -1);",
            "    parent.assign(n + 1, -1);",
            "    sz.assign(n + 1, 0);",
            "    order.assign(n, -1);",
            "",
            "    dfs_size(root);",
            "    top[root] = root;",
            "    dfs_hld(root);",
            "}",
            "",
            "long long queryPath(int u, int v)",
            "{",
            "    long long res = 0;",
            "",
            "    while (true)",
            "    {",
            "        if (in[u] > in[v])",
            "            swap(u, v);",
            "        if (top[u] == top[v])",
            "            break;",
            "        res += query(in[top[v]], in[v]);",
            "        v = parent[top[v]];",
            "    }",
            "    return res + query(in[u], in[v]);",
            "}",
            "",
            "void test()",
            "{",
            "    int q;",
            "    cin >> n >> q;",
            "    vector<int> a(n + 1);",
            "    for (int i = 1; i <= n; i++)",
            "        cin >> a[i];",
            "",
            "    graph.resize(n + 1);",
            "    for (int u, v, i = 1; i < n; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "",
            "    hld(1);",
            "",
            "    /* cach 1: cap nhap tung phan tu",
            "    for (int i = 0; i < n; i++)",
            "        update(in[i], a[i]);",
            "    */",
            "    // cach 2: build tree",
            "    vector<long long> temp(n);",
            "    for (int i = 1; i <= n; i++)",
            "        temp[in[i]] = a[i];",
            "    buildTree(temp);",
            "    int t, u, v;",
            "    while (q--)",
            "    {",
            "        cin >> t >> u >> v;",
            "        if (t == 1)",
            "            update(in[u], a[u] += v);",
            "        else",
            "            cout << queryPath(u, v) << \"\\n\";",
            "    }",
            "",
            "}"
        ],
        "description": "graph_hld"
    },
    "graph_lca_binaryLifting": {
        "prefix": "graph_lca_binaryLifting",
        "body": [
            "int n, level;",
            "vector<vector<int>> graph;",
            "int counter;",
            "vector<int> tin, tout;",
            "vector<vector<int>> parent;",
            "",
            "void dfs(int u, int p)",
            "{",
            "    tin[u] = ++counter;",
            "",
            "    parent[u][0] = p;",
            "    for(int v : graph[u])",
            "        if(v != p)",
            "            dfs(v, u);",
            "",
            "    tout[u] = ++counter;",
            "}",
            "",
            "void preprocess(int root)",
            "{",
            "    counter = 0;",
            "    dfs(root, root - 1);",
            "",
            "    for(int k = 1; k < level; k++)",
            "        for(int i = 1; i <= n; i++)",
            "            parent[i][k] = parent[parent[i][k - 1]][k - 1];",
            "}",
            "",
            "int isAncestor(int u, int v)",
            "{",
            "    return tin[u] <= tin[v] && tin[v] <= tout[u];",
            "}",
            "",
            "int lca(int u, int v)",
            "{",
            "    if(isAncestor(u, v)) return u;",
            "    if(isAncestor(v, u)) return v;",
            "",
            "    for(int k = level - 1; k >= 0; k--)",
            "        if(!isAncestor(parent[u][k], v))",
            "            u = parent[u][k];",
            "",
            "    return parent[u][0];",
            "}",
            "",
            "void test()",
            "{",
            "    int q, u, v;",
            "    cin >> n;",
            "    graph.assign(n + 1, vector<int>());",
            "    tin.assign(n + 1, 0); tout.assign(n + 1, 0);",
            "",
            "    level = ceil(log2(n));",
            "    parent.assign(n + 1, vector<int>(level));",
            "",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "    preprocess(1);",
            "    cin >> q;",
            "    while(q--)",
            "    {",
            "        cin >> u >> v;",
            "        cout << lca(u, v) << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "graph_lca_binaryLifting"
    },
    "graph_mst_kruskal": {
        "prefix": "graph_mst_kruskal",
        "body": [
            "typedef pair<int, int> pii;",
            "typedef pair<int, pii> piii;",
            "",
            "vector<piii> edges;",
            "int n, m;",
            "",
            "struct DisjointSet",
            "{",
            "    vector<int> parent, Rank;",
            "    DisjointSet(int n): parent(n + 1), Rank(n + 1, 0)",
            "    {",
            "        for (int i=1; i<=n; i++) parent[i] = i;",
            "    }",
            "    int findSet(int u)",
            "    {",
            "        if (parent[u] != u) parent[u] = findSet(parent[u]);",
            "        return parent[u];",
            "    }",
            "    bool unionSet(int u, int v)",
            "    {",
            "        int pu = findSet(u), pv = findSet(v);",
            "        if(pu == pv) return false;",
            "        if(Rank[pu] > Rank[pv]) parent[pv] = pu;",
            "        else if(Rank[pu] < Rank[pv]) parent[pu] = pv;",
            "        else",
            "        {",
            "            parent[pv] = pu;",
            "            Rank[pu]++;",
            "        }",
            "        return true;",
            "    }",
            "};",
            "",
            "int kruskal()",
            "{",
            "    int mst = 0;",
            "    int cnt = 0;",
            "",
            "    sort(edges.begin(), edges.end());",
            "    DisjointSet dsu(n);",
            "",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        u = edges[i].second.first;",
            "        v = edges[i].second.second;",
            "        w = edges[i].first;",
            "",
            "        if(dsu.unionSet(u, v))",
            "        {",
            "            cnt++;",
            "            mst += w;",
            "        }",
            "    }",
            "    return cnt == n - 1 ? mst : -1;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        edges.push_back(make_pair(w, make_pair(u, v)));",
            "    }",
            "",
            "    int mst = kruskal();",
            "    if(mst == -1)",
            "        cout << \"Graph is not connect\\n\";",
            "    else",
            "        cout << mst << \"\\n\";",
            "}"
        ],
        "description": "graph_mst_kruskal"
    },
    "graph_mst_prim": {
        "prefix": "graph_mst_prim",
        "body": [
            "const int INF = 1e9;",
            "",
            "typedef pair<int, int> pii;",
            "",
            "vector<int> dist, path;",
            "vector<bool> visited;",
            "vector<vector<pii>> adj;",
            "int n, m;",
            "",
            "bool prim()",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    visited.assign(n, false);",
            "",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, 0});",
            "    dist[0] = 0;",
            "",
            "    int count = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(visited[u]) continue;",
            "        visited[u] = true;",
            "        count++;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(!visited[v] && dist[v] > w)",
            "            {",
            "                dist[v] = w;",
            "                path[v] = u;",
            "                pq.push({w, v});",
            "            }",
            "        }",
            "    }",
            "    return count == n;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "",
            "    adj.assign(n, vector<pii>());",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        adj[u].push_back({v, w});",
            "        adj[v].push_back({u, w});",
            "    }",
            "",
            "    if(!prim()) cout << \"Graph is not connect\\n\";",
            "    else",
            "    {",
            "        int mst = 0;",
            "        for(int i = 0; i < n; i++)",
            "            mst += dist[i];",
            "        cout << \"MST: \" << mst << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "graph_mst_prim"
    },
    "graph_path_findEulerCycle": {
        "prefix": "graph_path_findEulerCycle",
        "body": [
            "vector<vector<int>> deg;",
            "int n, m;",
            "vector<int> result;",
            "",
            "void findEulerPath(int u)",
            "{",
            "    for(int v = 0; v < n; v++)",
            "    {",
            "        if(deg[u][v] > 0)",
            "        {",
            "            deg[u][v]--;",
            "            deg[v][u]--;",
            "            findEulerPath(v);",
            "        }",
            "    }",
            "    result.push_back(u);",
            "}",
            "",
            "void test()",
            "{",
            "    // Read data",
            "    cin >> n >> m;",
            "    deg.assign(n + 1, vector<int>(n + 1, 0));",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        deg[u][v]++;",
            "        deg[v][u]++;",
            "    }",
            "",
            "    int u = -1, v = -1;",
            "    bool isConnected = true, bad = false;",
            "",
            "    // check the degree",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        int cnt = 0;",
            "        for(int j = 0; j < n; j++)",
            "            cnt += deg[i][j];",
            "",
            "        if(cnt % 2 == 1)",
            "        {",
            "            if(u == -1)",
            "                u = i;",
            "            else if(v == -1)",
            "                v = i;",
            "            else",
            "            {",
            "                bad = true;",
            "                break;",
            "            }",
            "        }",
            "    }",
            "",
            "    // check and print cycle",
            "    if(bad)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u != -1)",
            "    {",
            "        deg[u][v]++; deg[v][u]++;",
            "        m++;",
            "    }",
            "    findEulerPath(0);",
            "    if((int)result.size() != m + 1)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u == -1)",
            "    {",
            "        cout << \"Euler cycle: \";",
            "        for(int v : result)",
            "            cout << v << \" \";",
            "        return;",
            "    }",
            "",
            "    for(int i = 0; i < (int)result.size(); i++)",
            "    {",
            "        if((result[i] == u && result[i + 1] == v) || (result[i] == v && result[i + 1] == u))",
            "        {",
            "            for(int j = 1; j <= i; j++)",
            "                result.push_back(result[j]);",
            "            result.erase(result.begin(), result.begin() + i + 1);",
            "            break;",
            "        }",
            "    }",
            "",
            "    cout << \"Euler Path: \";",
            "    for(int v : result)",
            "        cout << v << \" \";",
            "}"
        ],
        "description": "graph_path_findEulerCycle"
    },
    "graph_path_findEulerPath": {
        "prefix": "graph_path_findEulerPath",
        "body": [
            "vector<vector<int>> deg;",
            "int n, m;",
            "vector<int> result;",
            "",
            "void findEulerPath(int u)",
            "{",
            "    for(int v = 0; v < n; v++)",
            "    {",
            "        if(deg[u][v] > 0)",
            "        {",
            "            deg[u][v]--;",
            "            deg[v][u]--;",
            "            findEulerPath(v);",
            "        }",
            "    }",
            "    result.push_back(u);",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    deg.assign(n + 1, vector<int>(n + 1, 0));",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        deg[u][v]++;",
            "        deg[v][u]++;",
            "    }",
            "",
            "    findEulerPath(0);",
            "    for(int v : result)",
            "    {",
            "        cout << v << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_path_findEulerPath"
    },
    "graph_path_findHamiltonPath": {
        "prefix": "graph_path_findHamiltonPath",
        "body": [
            "vector<vector<int>> graph;",
            "int n, m;",
            "vector<int> path;",
            "vector<int> visited;",
            "",
            "void findHamiltonPath(int u)",
            "{",
            "    if((int)path.size()== n)",
            "    {",
            "        bool hasCycle = false;",
            "        for(int v : graph[u])",
            "            if(v == path[0])",
            "            {",
            "                hasCycle = true;",
            "                break;",
            "            }",
            "        if(hasCycle)",
            "            cout << \"found a Hamilton cycle\";",
            "        else",
            "            cout << \"found a Hamilton path\";",
            "        return;",
            "    }",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!visited[v])",
            "        {",
            "            visited[v] = true;",
            "            path.push_back(v);",
            "            findHamiltonPath(v);",
            "            path.pop_back();",
            "            visited[v] = false;",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_path_findHamiltonPath"
    },
    "graph_scc_bridgeCutVertex": {
        "prefix": "graph_scc_bridgeCutVertex",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> low, num;",
            "vector<bool> isCut;",
            "vector<pair<int, int>> bridges;",
            "int n, m;",
            "int counter;",
            "",
            "void dfs(int u, int p)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    int numChild = 0;",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(v == p) continue;",
            "        if(num[v] > 0)",
            "            low[u] = min(low[u], num[v]);",
            "        else",
            "        {",
            "            dfs(v, u);",
            "            low[u] = min(low[u], low[v]);",
            "            numChild++;",
            "            if(low[v] > num[u])",
            "                bridges.push_back(make_pair(u, v));",
            "            if(low[v] >= num[u] && p != -1)",
            "                isCut[u] = true;",
            "        }",
            "    }",
            "    if(p == -1 && numChild > 1)",
            "        isCut[u] = true;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    low.assign(n + 1, 0), num.assign(n + 1, 0);",
            "    isCut.assign(n + 1, false);",
            "    counter = 0;",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(!num[i])",
            "        {",
            "            dfs(i, -1);",
            "        }",
            "    }",
            "",
            "    cout << \"Bridges:\\n\";",
            "    for(int i = 0; i < bridges.size(); i++)",
            "    {",
            "        pair<int, int> b = bridges[i];",
            "        cout << b.first << \" \" << b.second << \"\\n\";",
            "    }",
            "    cout << \"Cut vertices:\";",
            "    for(int i = 1; i <= n; i++)",
            "        if(isCut[i])",
            "            cout << \" \" << i;",
            "    cout << \"\\n\";",
            "}"
        ],
        "description": "graph_scc_bridgeCutVertex"
    },
    "graph_scc_tarjan": {
        "prefix": "graph_scc_tarjan",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> low, num;",
            "vector<bool> found;",
            "stack<int> st;",
            "int n, m;",
            "int counter;",
            "",
            "void dfs(int u)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    st.push(u);",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!found[v])",
            "        {",
            "            if(num[v] > 0)",
            "                low[u] = min(low[u], num[v]);",
            "            else",
            "            {",
            "                dfs(v);",
            "                low[u] = min(low[u], low[v]);",
            "            }",
            "        }",
            "    }",
            "",
            "    if(num[u] == low[u])",
            "    {",
            "        cout << \"Found a SCC:\";",
            "        int v;",
            "        do",
            "        {",
            "            v = st.top();",
            "            st.pop();",
            "            cout << \" \" << v;",
            "            found[v] = true;",
            "        } while(v != u);",
            "        cout << \"\\n\";",
            "    }",
            "}",
            "",
            "void tarjan()",
            "{",
            "    counter = 0;",
            "    low.assign(n + 1, 0);",
            "    num.assign(n + 1, 0);",
            "    found.assign(n + 1, false);",
            "    st = stack<int>();",
            "",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(!num[i])",
            "        {",
            "            dfs(i);",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "    }",
            "    tarjan();",
            "}"
        ],
        "description": "graph_scc_tarjan"
    },
    "graph_shortestPath_bellmanFord": {
        "prefix": "graph_shortestPath_bellmanFord",
        "body": [
            "const int INF = 1e9;",
            "",
            "struct Edge",
            "{",
            "    int u, v, w;",
            "    Edge(int u = 0, int v = 0, int w = 0)",
            "        : u(u), v(v), w(w) {}",
            "};",
            "",
            "vector<int> dist, path;",
            "",
            "int bellmanFord(vector<Edge> &edges, int n, int m, int s)",
            "{",
            "    dist.assign(n + 1, INF);",
            "    path.assign(n + 1, -1);",
            "    dist[s] = 0;",
            "    int u, v, w;",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        for(int j = 0; j < m; j++)",
            "        {",
            "            u = edges[j].u;",
            "            v = edges[j].v;",
            "            w = edges[j].w;",
            "            if(dist[u] != INF && dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "            }",
            "        }",
            "    }",
            "",
            "    // check negative cycle",
            "    for(int j = 0; j < m; j++)",
            "    {",
            "        u = edges[j].u;",
            "        v = edges[j].v;",
            "        w = edges[j].w;",
            "        if(dist[u] != INF && dist[v] > dist[u] + w)",
            "        {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m;",
            "    cin >> n >> m;",
            "",
            "    vector<Edge> edges;",
            "    int u, v, w;",
            "    for(int i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        edges.push_back(Edge(u, v, w));",
            "    }",
            "",
            "    bellmanFord(edges, n, m, 1);",
            "    cout << dist[n];",
            "}"
        ],
        "description": "graph_shortestPath_bellmanFord"
    },
    "graph_shortestPath_dijkstra": {
        "prefix": "graph_shortestPath_dijkstra",
        "body": [
            "const int INF = 1e9;",
            "",
            "typedef pair<int, int> pii;",
            "",
            "vector<int> dist, path;",
            "vector<vector<pii>> adj;",
            "int n, m;",
            "",
            "void dijkstra(int s)",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, s});",
            "    dist[s] = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(tmp.first != dist[u]) continue;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    adj.assign(n, vector<pii>());",
            "    int u, v, w;",
            "    for(int i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        adj[u].push_back({v, w});",
            "    }",
            "",
            "    dijkstra(0);",
            "",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        cout << dist[i] << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_shortestPath_dijkstra"
    },
    "graph_shortestPath_floydWarshall": {
        "prefix": "graph_shortestPath_floydWarshall",
        "body": [
            "const int INF = 1e9;",
            "",
            "vector<vector<int>> dist, path;",
            "",
            "int floydWarshall(vector<vector<int>> &matrix, int n)",
            "{",
            "    dist.assign(n + 1, vector<int>(n + 1));",
            "    path.assign(n + 1, vector<int>(n + 1));",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        for(int j = 1; j <= n; j++)",
            "        {",
            "            dist[i][j] = i == j ? 0 : matrix[i][j];",
            "            if(i != j && dist[i][j] < INF)",
            "            {",
            "                path[i][j] = i;",
            "            }",
            "            else",
            "            {",
            "                path[i][j] = -1;",
            "            }",
            "        }",
            "    }",
            "    for(int k = 1; k <= n; k++)",
            "    {",
            "        for(int i = 1; i <= n; i++)",
            "        {",
            "            if(dist[i][k] >= INF) continue;",
            "            for(int j = 1; j <= n; j++)",
            "            {",
            "                if(dist[k][j] < INF && dist[i][j] > dist[i][k] + dist[k][j])",
            "                {",
            "                    dist[i][j] = dist[i][k] + dist[k][j];",
            "                    path[i][j] = path[k][j];",
            "                }",
            "            }",
            "        }",
            "    }",
            "    // check negative cycle",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(dist[i][i] < 0) return false;",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m;",
            "    cin >> n >> m;",
            "",
            "    vector<vector<int>> matrix(n + 1, vector<int>(n + 1, INF));",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v >> w;",
            "        matrix[u][v] = w;",
            "    }",
            "",
            "    floydWarshall(matrix, n);",
            "    for(int i = 1; i <= n; i++)",
            "        cout << dist[1][i] << \" \";",
            "}"
        ],
        "description": "graph_shortestPath_floydWarshall"
    },
    "graph_topo_dfs": {
        "prefix": "graph_topo_dfs",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> visited;",
            "vector<int> result;",
            "int n, m;",
            "",
            "/*",
            "Value of visited:",
            "- 0: not visit (not process)",
            "- 1: visiting (processing)",
            "- 2: visited (processed)",
            "*/",
            "bool dfs(int u)",
            "{",
            "    visited[u] = 1;",
            "    for(int v : graph[u])",
            "    {",
            "        if(visited[v] == 1) // cycle detected",
            "            return false;",
            "        if(visited[v] == 0)",
            "            if(dfs(v) == false)",
            "            {",
            "                return false;",
            "            }",
            "    }",
            "    result.push_back(u);",
            "    visited[u] = 2;",
            "    return true;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    visited.assign(n + 1, 0);",
            "",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "    }",
            "    bool flag = true;",
            "    for(int i = 1; i <= n && flag == true; i++)",
            "        if(!visited[i])",
            "            flag &= dfs(i);",
            "",
            "    if(!flag)",
            "        cout << \"Graph is not a DAG\";",
            "    else",
            "    {",
            "        for(int i = n - 1; i >= 0; i--)",
            "            cout << result[i] << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_topo_dfs"
    },
    "graph_topo_kahn": {
        "prefix": "graph_topo_kahn",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> indegree;",
            "vector<int> result;",
            "int n, m;",
            "",
            "bool kahn()",
            "{",
            "    queue<int> q;",
            "    for(int i = 1; i <= n; i++)",
            "        if(indegree[i] == 0)",
            "            q.push(i);",
            "",
            "    while(!q.empty())",
            "    {",
            "        int u = q.front(); q.pop();",
            "        result.push_back(u);",
            "        for(int i = 0; i < (int)graph[u].size(); i++)",
            "        {",
            "            indegree[graph[u][i]]--;",
            "            if(indegree[graph[u][i]] == 0)",
            "            {",
            "                q.push(graph[u][i]);",
            "            }",
            "        }",
            "    }",
            "",
            "    return result.size() == n;",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    indegree.assign(n + 1, 0);",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        indegree[v]++;",
            "    }",
            "    if(!kahn())",
            "        cout << \"Graph is not a DAG\";",
            "    else",
            "    {",
            "        for(int i = 0; i < n; i++)",
            "            cout << result[i] << \" \";",
            "    }",
            "}"
        ],
        "description": "graph_topo_kahn"
    },
    "graph_topo_sort": {
        "prefix": "graph_topo_sort",
        "body": [
            "vector<vector<int>> graph;",
            "vector<int> visited;",
            "vector<int> result;",
            "int n, m;",
            "",
            "void dfs(int u)",
            "{",
            "    visited[u] = true;",
            "    for(int v : graph[u])",
            "    {",
            "        if(!visited[v])",
            "            dfs(v);",
            "    }",
            "    result.push_back(u);",
            "}",
            "",
            "void test()",
            "{",
            "    cin >> n >> m;",
            "    graph.assign(n + 1, vector<int>());",
            "    visited.assign(n + 1, 0);",
            "",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "    }",
            "    for(int i = 1; i <= n; i++)",
            "        if(!visited[i])",
            "            dfs(i);",
            "    for(int i = n - 1; i >= 0; i--)",
            "        cout << result[i] << \" \";",
            "}"
        ],
        "description": "graph_topo_sort"
    },
    "graph_traversal_bfs": {
        "prefix": "graph_traversal_bfs",
        "body": [
            "vector<vector<int>> adj;",
            "vector<int> path;",
            "vector<bool> visited;",
            "",
            "void bfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    queue<int> q;",
            "",
            "    q.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!q.empty())",
            "    {",
            "        u = q.front();",
            "        q.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                q.push(v);",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m; cin >> n >> m;",
            "",
            "    adj.assign(n + 1, vector<int>());",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "    bfs(1);",
            "}"
        ],
        "description": "graph_traversal_bfs"
    },
    "graph_traversal_dfs_recursive": {
        "prefix": "graph_traversal_dfs_recursive",
        "body": [
            "vector<vector<int>> adj;",
            "vector<int> path;",
            "vector<bool> visited;",
            "",
            "void dfs(int s)",
            "{",
            "    visited[s] = true;",
            "",
            "    for(int i = 0; i < (int)adj[s].size(); i++)",
            "    {",
            "        int v = adj[s][i];",
            "",
            "        if(!visited[v])",
            "        {",
            "            path[v] = s;",
            "            dfs(v);",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m; cin >> n >> m;",
            "",
            "    adj.assign(n + 1, vector<int>());",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "",
            "    path.assign(n + 1, -1);",
            "    visited.assign(n + 1, false);",
            "    dfs(1);",
            "}"
        ],
        "description": "graph_traversal_dfs_recursive"
    },
    "graph_traversal_dfs_stack": {
        "prefix": "graph_traversal_dfs_stack",
        "body": [
            "vector<vector<int>> adj;",
            "vector<int> path;",
            "vector<bool> visited;",
            "",
            "void dfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    stack<int> st;",
            "",
            "    st.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!st.empty())",
            "    {",
            "        u = st.top();",
            "        st.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                st.push(v);",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "void test()",
            "{",
            "    int n, m; cin >> n >> m;",
            "",
            "    adj.assign(n + 1, vector<int>());",
            "    for(int u, v, i = 0; i < m; i++)",
            "    {",
            "        cin >> u >> v;",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "    dfs(1);",
            "}"
        ],
        "description": "graph_traversal_dfs_stack"
    },
    "misc_compressArray": {
        "prefix": "misc_compressArray",
        "body": [
            "void compressArray(vector<int>& a, int n)",
            "{",
            "    vector<int> b;",
            "    for(int i : a)",
            "        b.push_back(i);",
            "    sort(b.begin(), b.end());",
            "",
            "    unordered_map<int, int> zipIdx;",
            "    int newIdx = 1;",
            "    for(int i = 0; i < n i++)",
            "        if(i == 0 || b[i] != b[i - 1])",
            "        {",
            "            zipIdx[b[i]] = newIdx;",
            "            newIdx++;",
            "        }",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        a[i] = zipIdx[a[i]];",
            "    }",
            "}"
        ],
        "description": "misc_compressArray"
    },
    "misc_debug": {
        "prefix": "misc_debug",
        "body": [
            "void __print(int x) {cerr << x;}",
            "void __print(long x) {cerr << x;}",
            "void __print(long long x) {cerr << x;}",
            "void __print(unsigned x) {cerr << x;}",
            "void __print(unsigned long x) {cerr << x;}",
            "void __print(unsigned long long x) {cerr << x;}",
            "void __print(float x) {cerr << x;}",
            "void __print(double x) {cerr << x;}",
            "void __print(long double x) {cerr << x;}",
            "void __print(char x) {cerr << '\\'' << x << '\\'';}",
            "void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
            "",
            "template<typename T, typename V>",
            "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}",
            "template<typename T>",
            "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}",
            "void _print() {cerr << \"]\\n\";}",
            "template <typename T, typename... V>",
            "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
            "",
            "#define dbg(...) cerr<<__func__<<\":\"<<__LINE__<<\" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__);"
        ],
        "description": "misc_debug"
    },
    "numeric_chineseRemainder": {
        "prefix": "numeric_chineseRemainder",
        "body": [
            "int extend_gcd(int a, int b, int &x, int &y)",
            "{",
            "    if(b == 0)",
            "    {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    int x1, y1;",
            "    int g = extend_gcd(b, a % b, x1, y1);",
            "    x = y1;",
            "    y = x1 - y1 * (a / b);",
            "    return g;",
            "}",
            "",
            "int modInverse(int b, int m)",
            "{",
            "    int g, x, y;",
            "    g = extend_gcd(b, m, x, y);",
            "    if(g != 1)",
            "        return -1;",
            "    return x;",
            "}",
            "",
            "ll chineseRemainder(const vector<int>& a, const vector<int>& m, int mod)",
            "{",
            "    ll result = 0;",
            "    for(int i = 0; i < (int)a.size(); i++)",
            "    {",
            "        int M_i = mod / m[i];",
            "        int y_i = modInverse(M_i, m[i]);",
            "        result = (result + 1LL * a[i] * M_i * y_i) % mod;",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "numeric_chineseRemainder"
    },
    "numeric_lucas": {
        "prefix": "numeric_lucas",
        "body": [
            "vector<ll> f;",
            "",
            "void computeFactorials(int n, int mod)",
            "{",
            "    f.assign(n + 1, 0);",
            "    f[0] = 1;",
            "    for(int i = 1; i <= n; i++)",
            "        f[i] = (f[i - 1] * i) % mod;",
            "}",
            "",
            "ll fastPow(ll b, int p, int mod)",
            "{",
            "    if(!b) return 0;",
            "    if(!p) return 1;",
            "    ll res = fastPow(b, p / 2, mod);",
            "    res = (res * res) % mod;",
            "    if(p & 1)",
            "        res = (res * b) % mod;",
            "    return res;",
            "}",
            "",
            "ll nCkInverseModulo(int n, int k, int mod)",
            "{",
            "    ll res = f[n];",
            "    res = (res * fastPow(f[k], mod - 2, mod)) % mod;",
            "    res = (res * fastPow(f[n - k], mod - 2, mod)) % mod;",
            "    return res;",
            "}",
            "",
            "vector<int> getPresentation(int num, int base)",
            "{",
            "    vector<int> p;",
            "    while(num > 0)",
            "    {",
            "        p.push_back(num % base);",
            "        num /= base;",
            "    }",
            "    return p;",
            "}",
            "",
            "ll nCkLucas(int n, int k, int mod)",
            "{",
            "    vector<int> pN = getPresentation(n, mod);",
            "    vector<int> pK = getPresentation(k, mod);",
            "    ll res = 1;",
            "",
            "    for(int i = 0; i < (int)pK.size(); i++)",
            "        res = (res * nCkInverseModulo(pN[i], pK[i], mod)) % mod;",
            "    return res;",
            "}",
            "",
            "void test()",
            "{",
            "    int n = 18, k = 7, mod = 5;",
            "",
            "    computeFactorials(n, mod);",
            "",
            "    cout << \"nCk using inverse modulo: \" << nCkInverseModulo(n, k, mod) << \"\\n\";",
            "    cout << \"nCk using Lucas's theorem: \" << nCkInverseModulo(n, k, mod) << \"\\n\";",
            "}"
        ],
        "description": "numeric_lucas"
    },
    "numeric_matrix": {
        "prefix": "numeric_matrix",
        "body": [
            "template<class T>",
            "struct Matrix",
            "{",
            "    vector<vector<T>> a;",
            "    int n, m;",
            "",
            "    Matrix(int n = 0, int m = 0) : n(n), m(m)",
            "    {",
            "        a.assign(n, vector<T>(m, 0));",
            "    }",
            "",
            "    Matrix operator*(const Matrix& B)",
            "    {",
            "        Matrix C(this->n, B.m);",
            "",
            "        for(int i = 0; i < this->n; i++)",
            "            for(int j = 0; j < B.m; j++)",
            "                for(int k = 0; k < this->m; k++)",
            "                    C.a[i][j] += this->a[i][k] * B.a[k][j];",
            "",
            "        return C;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream& os, const Matrix<T>& mt)",
            "    {",
            "        for(int i = 0; i < mt.n; i++)",
            "        {",
            "            for(int j = 0; j < mt.m; j++)",
            "                os << mt.a[i][j] << \" \";",
            "            os << \"\\n\";",
            "        }",
            "        return os;",
            "    }",
            "",
            "    static Matrix Identity(int n)",
            "    {",
            "        Matrix I(n, n);",
            "        for(int i = 0; i < n; i++)",
            "            I.a[i][i] = 1;",
            "        return I;",
            "    }",
            "",
            "    friend Matrix pow(const Matrix& A, ll k)",
            "    {",
            "        if(k == 0) return Identity(A.n);",
            "        if(k == 1) return A;",
            "        Matrix Exp = pow(A, k / 2);",
            "        Exp = Exp * Exp;",
            "        if(k & 1)",
            "            Exp = Exp * A;",
            "        return Exp;",
            "    }",
            "};"
        ],
        "description": "numeric_matrix"
    },
    "numeric_mint": {
        "prefix": "numeric_mint",
        "body": [
            "template <int MOD>",
            "struct mint",
            "{",
            "\tint v;",
            "\texplicit operator int() const { return v; } // explicit -> don't silently convert to int",
            "\tmint() : v(0) {}",
            "\tmint(ll _v)",
            "\t{",
            "\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "\t\tif (v < 0)",
            "\t\t\tv += MOD;",
            "\t}",
            "\tfriend bool operator==(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn a.v == b.v;",
            "\t}",
            "\tfriend bool operator!=(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn !(a == b);",
            "\t}",
            "\tfriend bool operator<(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn a.v < b.v;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &o)",
            "\t{",
            "\t\tif ((v += o.v) >= MOD)",
            "\t\t\tv -= MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &o)",
            "\t{",
            "\t\tif ((v -= o.v) < 0)",
            "\t\t\tv += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &o)",
            "\t{",
            "\t\tv = int((ll)v * o.v % MOD);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }",
            "\tfriend mint pow(mint a, ll p)",
            "\t{",
            "\t\tmint ans = 1;",
            "\t\tassert(p >= 0);",
            "\t\tfor (; p; p /= 2, a *= a)",
            "\t\t\tif (p & 1)",
            "\t\t\t\tans *= a;",
            "\t\treturn ans;",
            "\t}",
            "\tfriend mint inv(const mint &a)",
            "\t{",
            "\t\tassert(a.v != 0);",
            "\t\treturn pow(a, MOD - 2);",
            "\t}",
            "",
            "\tmint operator-() const { return mint(-v); }",
            "\tmint &operator++() { return *this += 1; }",
            "\tmint &operator--() { return *this -= 1; }",
            "\tfriend mint operator+(mint a, const mint &b) { return a += b; }",
            "\tfriend mint operator-(mint a, const mint &b) { return a -= b; }",
            "\tfriend mint operator*(mint a, const mint &b) { return a *= b; }",
            "\tfriend mint operator/(mint a, const mint &b) { return a /= b; }",
            "\tfriend ostream &operator<<(ostream &os, const mint &m)",
            "\t{",
            "\t\treturn os << m.v;",
            "\t}",
            "\tfriend istream &operator>>(istream &is, mint &m)",
            "\t{",
            "\t\tll x;",
            "\t\tis >> x;",
            "\t\tm.v = x;",
            "\t\treturn is;",
            "\t}",
            "};"
        ],
        "description": "numeric_mint"
    },
    "numeric_prime_isPrime": {
        "prefix": "numeric_prime_isPrime",
        "body": [
            "bool isPrime(int n)",
            "{",
            "    if(n < 2) return false;",
            "    for(int i = 0; i * i <= n; i++)",
            "        if(n % i == 0) return false;",
            "    return true;",
            "}"
        ],
        "description": "numeric_prime_isPrime"
    },
    "numeric_prime_phiEuler": {
        "prefix": "numeric_prime_phiEuler",
        "body": [
            "int phiEuler(int n)",
            "{",
            "    int result = n;",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        if(n % i == 0)",
            "        {",
            "            while(n % i == 0) n /= i;",
            "            result = result / i * (i - 1);",
            "        }",
            "    }",
            "",
            "    if(n != 1) result = result / n * (n - 1);",
            "    return result;",
            "}"
        ],
        "description": "numeric_prime_phiEuler"
    },
    "numeric_prime_primeFactorization": {
        "prefix": "numeric_prime_primeFactorization",
        "body": [
            "void primeFactorization(int n)",
            "{",
            "    cout << n << \" = \";",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        while(n % i == 0)",
            "        {",
            "            cout << i << \" \";",
            "            n /= i;",
            "        }",
            "    }",
            "",
            "    if(n != 1) cout << n;",
            "}"
        ],
        "description": "numeric_prime_primeFactorization"
    },
    "numeric_prime_segmentedSieve": {
        "prefix": "numeric_prime_segmentedSieve",
        "body": [
            "vector<bool> isPrime;",
            "vector<int> primes;",
            "",
            "void segmentedSieve(int l, int r, const vector<int>& basePrimes)",
            "{",
            "    isPrime.assign(r - l + 1, true);",
            "    for(int p : basePrimes)",
            "    {",
            "        int fr = ((l - 1) / p + 1) * p;",
            "        for(int j = fr; j <= r; j += p)",
            "            isPrime[j - l] = false;",
            "    }",
            "",
            "    for(int i = l; i <= r; i++)",
            "        if(isPrime[i - l]) primes.push_back(i);",
            "}"
        ],
        "description": "numeric_prime_segmentedSieve"
    },
    "numeric_prime_sieveOfEratosthenes": {
        "prefix": "numeric_prime_sieveOfEratosthenes",
        "body": [
            "vector<bool> isPrime;",
            "vector<int> primes;",
            "",
            "void sieveOfEratosthenes(int n)",
            "{",
            "    isPrime.assign(n + 1, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    for(int i = 2; i * i <= n; i++)",
            "        if(isPrime[i])",
            "        {",
            "            for(int j = i * i; j <= n; j += i)",
            "                isPrime[j] = false;",
            "        }",
            "",
            "    for(int i = 2; i<= n; i++)",
            "        if(isPrime[i]) primes.push_back(i);",
            "}"
        ],
        "description": "numeric_prime_sieveOfEratosthenes"
    },
    "numeric_search_binary": {
        "prefix": "numeric_search_binary",
        "body": [
            "int binarySearch(int a[], int left, int right, int x)",
            "{",
            "    int res = right;",
            "    while(left < right)",
            "    {",
            "        int mid = left + (right - left) / 2;",
            "        if(a[mid] >= x)",
            "        {",
            "            res = mid;",
            "            right = mid;",
            "        }",
            "        else",
            "        {",
            "            left = mid + 1;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "numeric_search_binary"
    },
    "numeric_search_ternary": {
        "prefix": "numeric_search_ternary",
        "body": [
            "double max_f(double left, double right)",
            "{",
            "    int N_ITER = 100;",
            "",
            "    for (int i = 0; i < N_ITER; i++)",
            "    {",
            "        double x1 = left + (right - left) / 3.0;",
            "        double x2 = right - (right - left) / 3.0;",
            "",
            "        if (f(x1) > f(x2))",
            "            right = x2;",
            "        else",
            "            left = x1;",
            "    }",
            "    return f(left);",
            "}"
        ],
        "description": "numeric_search_ternary"
    },
    "string_kmp": {
        "prefix": "string_kmp",
        "body": [
            "vector<int> kmpPreprocess(string p)",
            "{",
            "    int m = p.length();",
            "    vector<int> pref(m, 0);",
            "",
            "    int j = 0;",
            "    for(int i = 1; i < m; i++)",
            "    {",
            "        while(j > 0 && p[j] != p[i])",
            "            j = pref[j - 1];",
            "        if(p[i] == p[j])",
            "            j++;",
            "        pref[i] = j;",
            "    }",
            "",
            "    return pref;",
            "}",
            "",
            "vector<int> kmpSearch(string t, string p, vector<int>& pref)",
            "{",
            "    int n = t.length(), m = p.length();",
            "    vector<int> found;",
            "",
            "    int j = 0;",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        while(j > 0 && t[i] != p[j])",
            "            j = pref[j - 1];",
            "        if(t[i] == p[j])",
            "            j++;",
            "",
            "        if(j == m)",
            "        {",
            "            found.push_back(i - m + 1);",
            "            j = pref[j - 1];",
            "        }",
            "    }",
            "",
            "    return found;",
            "}"
        ],
        "description": "string_kmp"
    },
    "string_lcp": {
        "prefix": "string_lcp",
        "body": [
            "vector<int> computeLCP(const string& s, const vector<int>& SA)",
            "{",
            "    int n = SA.size();",
            "    vector<int> LCP(n), PLCP(n), c(n, 0);",
            "",
            "    for(int i = 0; i < n; i++)",
            "        c[SA[i]] = i;",
            "    int k = 0;",
            "    for(int j, i = 0; i < n - 1; i++)",
            "    {",
            "        j = SA[c[i] - 1];",
            "        k = max(k - 1, 0);",
            "        while (s[i + k] == s[j + k]) k++;",
            "        PLCP[i] = k;",
            "    }",
            "",
            "    for(int i = 0; i < n; i++)",
            "        LCP[i] = PLCP[SA[i]];",
            "",
            "    return LCP;",
            "}"
        ],
        "description": "string_lcp"
    },
    "string_manacher": {
        "prefix": "string_manacher",
        "body": [
            "vector<int> manacher(string s)",
            "{",
            "    int n = s.length();",
            "    vector<int> p(n);",
            "    int l = 0, r = -1;",
            "    for (int i = 0; i < n; i++)",
            "    {",
            "        int k = i > r ? 0 : min(p[l + r - i], r - i);",
            "        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])",
            "            k++;",
            "        p[i] = --k;",
            "        if (i + k > r)",
            "        {",
            "            l = i - k;",
            "            r = i + k;",
            "        }",
            "    }",
            "    return p;",
            "}",
            "",
            "void test()",
            "{",
            "    string s;",
            "    cin >> s;",
            "    string t(2 * s.length() + 1, '#');",
            "    for (int i = 0; i < (int)s.length(); i++)",
            "        t[2 * i + 1] = s[i];",
            "",
            "    vector<int> p = manacher(t);",
            "    for (int i = 1; i < (int)p.size() - 1; i++)",
            "    {",
            "        if(p[i] > 0)",
            "            cout << p[i] << \" \" << s.substr((i - p[i]) / 2, p[i]) << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "string_manacher"
    },
    "string_string_matching": {
        "prefix": "string_string_matching",
        "body": [
            "int findSubstring(const string& s, const vector<int>& SA, const string& p)",
            "{",
            "    int m, l = 0, r = s.length();",
            "",
            "    while(l < r)",
            "    {",
            "        m = (l + r) >> 1;",
            "        int cmp = s.compare(SA[m], p.length(), p);",
            "        if(cmp == 0)",
            "            return SA[m];",
            "        if(cmp < 0)",
            "            l = m + 1;",
            "        else",
            "            r = m;",
            "    }",
            "",
            "    return -1;",
            "}"
        ],
        "description": "string_string_matching"
    },
    "string_suffixArray": {
        "prefix": "string_suffixArray",
        "body": [
            "const int MAX_DIGIT = 256;",
            "",
            "void countingSort(vector<int>& SA, vector<int>& RA, int k = 0)",
            "{",
            "    int n = SA.size();",
            "    vector<int> cnt(max(MAX_DIGIT, n), 0);",
            "",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        if(i + k < n)",
            "            cnt[RA[i + k]]++;",
            "        else",
            "            cnt[0]++;",
            "    }",
            "    for(int i = 1; i < (int)cnt.size(); i++)",
            "        cnt[i] += cnt[i - 1];",
            "    vector<int> tempSA(n);",
            "    for(int i = n - 1; i >= 0; i--)",
            "        if(SA[i] + k < n)",
            "            tempSA[--cnt[RA[SA[i] + k]]] = SA[i];",
            "        else",
            "            tempSA[--cnt[0]] = SA[i];",
            "    SA = tempSA;",
            "}",
            "",
            "vector<int> constructSA(string s)",
            "{",
            "    int n = s.length();",
            "    vector<int> SA(n);",
            "    vector<int> RA(n);",
            "    vector<int> tempRA(n);",
            "",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        RA[i] = s[i];",
            "        SA[i] = i;",
            "    }",
            "",
            "    for(int step = 1; step < n; step <<= 1)",
            "    {",
            "        countingSort(SA, RA, step);",
            "        countingSort(SA, RA, 0);",
            "",
            "        tempRA[SA[0]] = 0;",
            "        for(int i = 1; i < n; i++)",
            "        {",
            "            if(RA[SA[i]] == RA[SA[i - 1]] && RA[SA[i] + step] == RA[SA[i - 1] + step])",
            "                tempRA[SA[i]] = tempRA[SA[i - 1]];",
            "            else",
            "                tempRA[SA[i]] = tempRA[SA[i - 1]] + 1;",
            "        }",
            "        RA = tempRA;",
            "        if(RA[SA[n - 1]] == n - 1) break;",
            "    }",
            "    return SA;",
            "}",
            "",
            "void test()",
            "{",
            "    string s;",
            "    cin >> s;",
            "    s += \"$\";",
            "    vector<int> SA = constructSA(s);",
            "    for(int i = 0; i < (int)SA.size(); i++)",
            "        cout << SA[i] << \" \" << s.substr(SA[i]) << \"\\n\";",
            "}"
        ],
        "description": "string_suffixArray"
    },
    "string_trie": {
        "prefix": "string_trie",
        "body": [
            "const int MAX = 26;",
            "",
            "struct Node",
            "{",
            "    Node* child[MAX];",
            "    int count;",
            "",
            "    Node()",
            "    {",
            "        count = 0;",
            "        fill(child, child + MAX, nullptr);",
            "    }",
            "};",
            "",
            "void add(Node* root, string s)",
            "{",
            "    Node* cur = root;",
            "    for(char ch : s)",
            "    {",
            "        int c = ch - 'a';",
            "        if(cur->child[c] == nullptr)",
            "            cur->child[c] = new Node();",
            "        cur = cur->child[c];",
            "    }",
            "    cur->count++;",
            "}",
            "",
            "bool search(Node* root, string s)",
            "{",
            "    Node* cur = root;",
            "    for(char ch : s)",
            "    {",
            "        int c = ch - 'a';",
            "        if(cur->child[c] == nullptr)",
            "            return false;",
            "        cur = cur->child[c];",
            "    }",
            "    return cur->count > 0;",
            "}",
            "",
            "bool isEmpty(Node& temp)",
            "{",
            "    for(int i = 0; i < MAX; i++)",
            "        if(temp.child[i] != nullptr)",
            "            return false;",
            "    return true;",
            "}",
            "",
            "bool remove(Node* root, string s, int depth = 0)",
            "{",
            "    if(!root) return false;",
            "    if(depth == s.length())",
            "    {",
            "        if(root->count > 0)",
            "        {",
            "            root->count--;",
            "            return true;",
            "        }",
            "        return false;",
            "    }",
            "",
            "    int c = s[depth] - 'a';",
            "    if(!root->child[c])",
            "        return false;",
            "    bool isRemoved = remove(root->child[c], s, depth + 1);",
            "    Node& temp = *(root->child[c]);",
            "    if(isRemoved && temp.count == 0 && isEmpty(temp))",
            "    {",
            "        delete root->child[c];",
            "        root->child[c] = nullptr;",
            "    }",
            "    return isRemoved;",
            "}",
            "",
            "void test()",
            "{",
            "    Node* root = new Node();",
            "    add(root, \"bigo\");",
            "    add(root, \"complete\");",
            "    add(root, \"algo\");",
            "    add(root, \"algorithm\");",
            "    cout << search(root, \"competitive\") << \"\\n\";",
            "    cout << search(root, \"big\") << \"\\n\";",
            "    cout << search(root, \"algorithm\") << \"\\n\";",
            "    cout << remove(root, \"algorithm\") << \"\\n\";",
            "    cout << remove(root, \"comp\") << \"\\n\";",
            "    cout << remove(root, \"competitive\") << \"\\n\";",
            "}"
        ],
        "description": "string_trie"
    },
    "string_Zfunction": {
        "prefix": "string_Zfunction",
        "body": [
            "vector<int> z_function(string s)",
            "{",
            "    int n = (int)s.length();",
            "    vector<int> z(n);",
            "    for(int i = 1, l = 0, r = 0; i < n; i++)",
            "    {",
            "        if(i <= r)",
            "            z[i] = min(r - i + 1, z[i - l]);",
            "        while(i + z[i] < n && s[z[i]] == s[i + z[i]])",
            "            ++z[i];",
            "        if(i + z[i] - 1 > r)",
            "            l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "string_Zfunction"
    },
    "template_gfg": {
        "prefix": "template_gfg",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "",
            "const int MOD = 1e9 + 7;",
            "const int N = 1e5 + 7;",
            "",
            "void solve()",
            "{",
            "",
            "}",
            "",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "",
            "    int t = 1;",
            "    cin >> t;",
            "",
            "    while(t--)",
            "        solve();",
            "",
            "    return 0;",
            "}"
        ],
        "description": "template_gfg"
    }
}