{
    "template_gfg": {
        "prefix": "template_gfg",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "",
            "void solve()",
            "{",
            "",
            "}",
            "",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "",
            "    int t = 1;",
            "    cin >> t;",
            "",
            "    while(t--)",
            "        solve();",
            "",
            "    return 0;",
            "}"
        ],
        "description": "template_gfg"
    },
    "misc_debug": {
        "prefix": "misc_debug",
        "body": [
            "void __print(int x) {cerr << x;}",
            "void __print(long x) {cerr << x;}",
            "void __print(long long x) {cerr << x;}",
            "void __print(unsigned x) {cerr << x;}",
            "void __print(unsigned long x) {cerr << x;}",
            "void __print(unsigned long long x) {cerr << x;}",
            "void __print(float x) {cerr << x;}",
            "void __print(double x) {cerr << x;}",
            "void __print(long double x) {cerr << x;}",
            "void __print(char x) {cerr << '\\'' << x << '\\'';}",
            "void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
            "",
            "template<typename T, typename V>",
            "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}",
            "template<typename T>",
            "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}",
            "void _print() {cerr << \"]\\n\";}",
            "template <typename T, typename... V>",
            "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
            "",
            "#define dbg(...) cerr<<__func__<<\":\"<<__LINE__<<\" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__);"
        ],
        "description": "misc_debug"
    },
    "graph_topo_dfs": {
        "prefix": "graph_topo_dfs",
        "body": [
            "bool topo_dfs(int u)",
            "{",
            "    visited[u] = 1;",
            "    for(int i = 0; i < (int)graph[u].size(); i++)",
            "    {",
            "        if(visited[graph[u][i]] == 1)",
            "        {",
            "            return false;",
            "        }",
            "        if(visited[graph[u][i]] == 0)",
            "        {",
            "            if(topo_dfs(graph[u][i]) == false)",
            "                return false;",
            "        }",
            "    }",
            "    result.push_back(u);",
            "    visited[u] = 2;",
            "    return true;",
            "}"
        ],
        "description": "graph_topo_dfs"
    },
    "graph_findHamiltonPath": {
        "prefix": "graph_findHamiltonPath",
        "body": [
            "void findHamiltonPath(int u)",
            "{",
            "    if((int)path.size()== n)",
            "    {",
            "        bool hasCycle = false;",
            "        for(int v : graph[u])",
            "            if(v == path[0])",
            "            {",
            "                hasCycle = true;",
            "                break;",
            "            }",
            "        if(hasCycle)",
            "            cout << \"found a Hamilton cycle\";",
            "        else",
            "            cout << \"found a Hamilton path\";",
            "        return;",
            "    }",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!visited[v])",
            "        {",
            "            visited[v] = true;",
            "            path.push_back(v);",
            "            findHamiltonPath(v);",
            "            path.pop_back();",
            "            visited[v] = false;",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_findHamiltonPath"
    },
    "graph_prim": {
        "prefix": "graph_prim",
        "body": [
            "bool prim()",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    visited.assign(n, false);",
            "",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, 0});",
            "    dist[0] = 0;",
            "",
            "    int count = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(visited[u]) continue;",
            "        visited[u] = true;",
            "        count++;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(!visited[v] && dist[v] > w)",
            "            {",
            "                dist[v] = w;",
            "                path[v] = u;",
            "                pq.push({w, v});",
            "            }",
            "        }",
            "    }",
            "    return count == n;",
            "}"
        ],
        "description": "graph_prim"
    },
    "graph_bellmanFord": {
        "prefix": "graph_bellmanFord",
        "body": [
            "int bellmanFord(vector<Edge> &edges, int n, int m, int s)",
            "{",
            "    dist.assign(n + 1, INF);",
            "    path.assign(n + 1, -1);",
            "    dist[s] = 0;",
            "    int u, v, w;",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        for(int j = 0; j < m; j++)",
            "        {",
            "            u = edges[j].u;",
            "            v = edges[j].v;",
            "            w = edges[j].w;",
            "            if(dist[u] != INF && dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "            }",
            "        }",
            "    }",
            "    for(int j = 0; j < m; j++)",
            "    {",
            "        u = edges[j].u;",
            "        v = edges[j].v;",
            "        w = edges[j].w;",
            "        if(dist[u] != INF && dist[v] > dist[u] + w)",
            "        {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "graph_bellmanFord"
    },
    "graph_kahn": {
        "prefix": "graph_kahn",
        "body": [
            "bool kahn()",
            "{",
            "    queue<int> q;",
            "    for(int i = 1; i <= n; i++)",
            "        if(indegree[i] == 0)",
            "            q.push(i);",
            "    while(!q.empty())",
            "    {",
            "        int u = q.front(); q.pop();",
            "        result.push_back(u);",
            "        for(int i = 0; i < (int)graph[u].size(); i++)",
            "        {",
            "            indegree[graph[u][i]]--;",
            "            if(indegree[graph[u][i]] == 0)",
            "            {",
            "                q.push(graph[u][i]);",
            "            }",
            "        }",
            "    }",
            "    return result.size() == n;",
            "}"
        ],
        "description": "graph_kahn"
    },
    "graph_bfs": {
        "prefix": "graph_bfs",
        "body": [
            "void bfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    queue<int> q;",
            "",
            "    q.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!q.empty())",
            "    {",
            "        u = q.front();",
            "        q.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                q.push(v);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_bfs"
    },
    "graph_Edge": {
        "prefix": "graph_Edge",
        "body": [
            "struct Edge",
            "{",
            "    int u, v, w;",
            "    Edge(int u = 0, int v = 0, int w = 0)",
            "        : u(u), v(v), w(w) {}",
            "    bool operator<(const Edge& other) const",
            "    {",
            "        return w < other.w;",
            "    }",
            "};"
        ],
        "description": "graph_Edge"
    },
    "graph_floyWarshall": {
        "prefix": "graph_floyWarshall",
        "body": [
            "int floydWarshall(vector<vector<int>> &matrix, int n)",
            "{",
            "    dist.assign(n + 1, vector<int>(n + 1));",
            "    path.assign(n + 1, vector<int>(n + 1));",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        for(int j = 1; j <= n; j++)",
            "        {",
            "            dist[i][j] = i == j ? 0 : matrix[i][j];",
            "            if(i != j && dist[i][j] < INF)",
            "            {",
            "                path[i][j] = i;",
            "            }",
            "            else",
            "            {",
            "                path[i][j] = -1;",
            "            }",
            "        }",
            "    }",
            "    for(int k = 1; k <= n; k++)",
            "    {",
            "        for(int i = 1; i <= n; i++)",
            "        {",
            "            if(dist[i][k] >= INF) continue;",
            "            for(int j = 1; j <= n; j++)",
            "            {",
            "                if(dist[k][j] < INF && dist[i][j] > dist[i][k] + dist[k][j])",
            "                {",
            "                    dist[i][j] = dist[i][k] + dist[k][j];",
            "                    path[i][j] = path[k][j];",
            "                }",
            "            }",
            "        }",
            "    }",
            "    // check negative cycle",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(dist[i][j] < 0) return false;",
            "    }",
            "}"
        ],
        "description": "graph_floyWarshall"
    },
    "graph_bridgeCutVertex": {
        "prefix": "graph_bridgeCutVertex",
        "body": [
            "void bridgeCutVertex(int u, int p)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    int numChild = 0;",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(v == p) continue;",
            "        if(num[v] > 0)",
            "            low[u] = min(low[u], num[v]);",
            "        else",
            "        {",
            "            bridgeCutVertex(v, u);",
            "            low[u] = min(low[u], low[v]);",
            "            numChild++;",
            "            if(low[v] > num[u])",
            "                bridge.push_back(make_pair(u, v));",
            "            if(low[v] >= num[u] && p != -1)",
            "                isCut[u] = true;",
            "        }",
            "    }",
            "    if(p == -1 && numChild > 1)",
            "        isCut[u] = true;",
            "}"
        ],
        "description": "graph_bridgeCutVertex"
    },
    "graph_kruskal": {
        "prefix": "graph_kruskal",
        "body": [
            "int kruskal()",
            "{",
            "    int mst = 0;",
            "    int cnt = 0;",
            "",
            "    sort(edges.begin(), edges.end());",
            "    DisjointSet djs(n);",
            "",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        u = edges[i].u;",
            "        v = edges[i].v;",
            "        w = edges[i].w;",
            "",
            "        if(djs.unionSet(u, v))",
            "        {",
            "            cnt++;",
            "            mst += w;",
            "        }",
            "    }",
            "    return cnt == n - 1 ? mst : -1;",
            "}"
        ],
        "description": "graph_kruskal"
    },
    "graph_dijkstra": {
        "prefix": "graph_dijkstra",
        "body": [
            "void dijkstra(int s)",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, s});",
            "    dist[s] = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(tmp.first != dist[u]) continue;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_dijkstra"
    },
    "graph_tarjan": {
        "prefix": "graph_tarjan",
        "body": [
            "void tarjan(int u)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    st.push(u);",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!found[v])",
            "        {",
            "            if(num[v] > 0)",
            "                low[u] = min(low[u], num[v]);",
            "            else",
            "            {",
            "                dfs_tarjan(v);",
            "                low[u] = min(low[u], low[v]);",
            "            }",
            "        }",
            "    }",
            "    if(num[u] == low[u])",
            "    {",
            "        cout << \"Found a SCC:\";",
            "        int v;",
            "        do",
            "        {",
            "            v = st.top();",
            "            st.pop();",
            "            cout << \" \" << v;",
            "            found[v] = true;",
            "        } while(v != u);",
            "        cout << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "graph_tarjan"
    },
    "graph_findEulerCycle": {
        "prefix": "graph_findEulerCycle",
        "body": [
            "void findEulerCycle()",
            "{",
            "    int u = -1, v = -1;",
            "    bool isConnected = true, bad = false;",
            "",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        int cnt = 0;",
            "        for(int j = 0; j < n; j++)",
            "            cnt += g[i][j];",
            "",
            "        if(cnt % 2 == 1)",
            "        {",
            "            if(u == -1)",
            "                u = i;",
            "            else if(v == -1)",
            "                v = i;",
            "            else",
            "            {",
            "                bad = true;",
            "                break;",
            "            }",
            "        }",
            "    }",
            "",
            "    if(bad)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u != -1)",
            "    {",
            "        g[u][v]++; g[v][u]++;",
            "        m++;",
            "    }",
            "    findEulerPath(0);",
            "    if((int)result.size() != m + 1)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u == -1)",
            "    {",
            "        cout << \"Euler cycle: \";",
            "        for(int v : result)",
            "            cout << v << \" \";",
            "        return;",
            "    }",
            "",
            "    for(int i = 0; i < (int)result.size(); i++)",
            "    {",
            "        if((result[i] == u && result[i + 1] == v) || (result[i] == v && result[i + 1] == u))",
            "        {",
            "            for(int j = 1; j <= i; j++)",
            "                result.push_back(result[j]);",
            "            result.erase(result.begin(), result.begin() + i + 1);",
            "            break;",
            "        }",
            "    }",
            "",
            "    cout << \"Euler Path: \"",
            "    for(int v : result)",
            "        cout << v << \" \";",
            "}"
        ],
        "description": "graph_findEulerCycle"
    },
    "graph_Graph": {
        "prefix": "graph_Graph",
        "body": [
            "struct Graph",
            "{",
            "",
            "};"
        ],
        "description": "graph_Graph"
    },
    "graph_lca_sqrt_decomposition": {
        "prefix": "graph_lca_sqrt_decomposition",
        "body": [
            "int n;",
            "vector<vector<int>> graph;",
            "int block_size;",
            "vector<int> level, parent, jump_parent;",
            "",
            "Graph(int n_)",
            "{",
            "    n = n_;",
            "    graph.assign(n + 1, vector<int>());",
            "    level.assign(n + 1);",
            "    parent.assign(n + 1);",
            "    jump_parent.assign(n + 1);",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "}",
            "",
            "int getDepth(int u, int p)",
            "{",
            "    int res = 0;",
            "    for(int v : graph[u])",
            "        if(v != p)",
            "            res = max(res, getDepth(v, u));",
            "    return res + 1;",
            "}",
            "",
            "void dfs(int u, int p)",
            "{",
            "    level[u] = level[p] + 1;",
            "    parent[u] = p;",
            "    if(level[u] % block_size == 0)",
            "        jump_parent[u] = p;",
            "    else",
            "        jump_parent[u] = jump_parent[p];",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(v != p)",
            "            dfs(v, u);",
            "    }",
            "}",
            "",
            "void preprocess()",
            "{",
            "    int height = getDepth(0, 1);",
            "    block_size = sqrt(height);",
            "    level[0] = -1;",
            "    dfs(1, 0);",
            "}",
            "",
            "int lca(int u, int v)",
            "{",
            "    if(level[u] > level[v]) swap(u, v);",
            "    while(level[u] < level[v])",
            "    {",
            "        if(level[jump_parent[v]] > level[u])",
            "            v = jump_parent[v];",
            "        else",
            "            v = parent[v];",
            "    }",
            "    while (u != v)",
            "    {",
            "        if(jump_parent[u] == jump_parent[v])",
            "        {",
            "            u = parent[u];",
            "            v = parent[v];",
            "        }",
            "        else",
            "        {",
            "            u = jump_parent[u];",
            "            v = jump_parent[v];",
            "        }",
            "    }",
            "",
            "    return u;",
            "}"
        ],
        "description": "graph_lca_sqrt_decomposition"
    },
    "graph_lca_sparseTable_binaryLifting": {
        "prefix": "graph_lca_sparseTable_binaryLifting",
        "body": [
            "int n, level;",
            "vector<vector<int>> graph;",
            "int counter;",
            "vector<int> tin, tout;",
            "vector<vector<int>> parent;",
            "",
            "Graph(int n_)",
            "{",
            "    n = n_;",
            "    graph.assign(n + 1, vector<int>());",
            "    tin.assign(n + 1, 0); tout.assign(n + 1, 0);",
            "",
            "    level = ceil(log2(n));",
            "    parent.assign(n + 1, vector<int>(level));",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        int u, v;",
            "        cin >> u >> v;",
            "        graph[u].push_back(v);",
            "        graph[v].push_back(u);",
            "    }",
            "}",
            "",
            "void dfs(int u, int p)",
            "{",
            "    tin[u] = ++counter;",
            "",
            "    parent[u][0] = p;",
            "    for(int v : graph[u])",
            "        if(v != p)",
            "            dfs(v, u);",
            "",
            "    tout[u] = ++counter;",
            "}",
            "",
            "void preprocess(int root)",
            "{",
            "    counter = 0;",
            "    dfs(root, root);",
            "",
            "    for(int k = 1; k < level; k++)",
            "        for(int i = 1; i <= n; i++)",
            "            parent[i][k] = parent[parent[i][k - 1]][k - 1];",
            "}",
            "",
            "int isAncestor(int u, int v)",
            "{",
            "    return tin[u] <= tin[v] && tin[v] <= tout[u];",
            "}",
            "",
            "int lca(int u, int v)",
            "{",
            "    if(isAncestor(u, v)) return u;",
            "    if(isAncestor(v, u)) return v;",
            "",
            "    for(int k = level - 1; k >= 0; k--)",
            "        if(!isAncestor(parent[u][k], v))",
            "            u = parent[u][k];",
            "",
            "    return parent[u][0];",
            "}"
        ],
        "description": "graph_lca_sparseTable_binaryLifting"
    },
    "graph_dfs_recursive": {
        "prefix": "graph_dfs_recursive",
        "body": [
            "void dfs(int s)",
            "{",
            "    visited[s] = true;",
            "",
            "    for(int i = 0; i < (int)adj[s].size(); i++)",
            "    {",
            "        int v = adj[s][i];",
            "",
            "        if(!visited[v])",
            "        {",
            "            path[v] = s;",
            "            dfs(v);",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_dfs_recursive"
    },
    "graph_dfs_stack": {
        "prefix": "graph_dfs_stack",
        "body": [
            "void dfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    stack<int> st;",
            "",
            "    st.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!st.empty())",
            "    {",
            "        u = st.top();",
            "        st.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                st.push(v);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_dfs_stack"
    },
    "graph_findEulerPath_recursive": {
        "prefix": "graph_findEulerPath_recursive",
        "body": [
            "void findEulerPath(int u)",
            "{",
            "    for(int v = 0; v < n; v++)",
            "    {",
            "        if(g[u][v] > 0)",
            "        {",
            "            g[u][v]--;",
            "            g[v][u]--;",
            "            findEulerPath(v);",
            "        }",
            "    }",
            "    result.push_back(u);",
            "}"
        ],
        "description": "graph_findEulerPath_recursive"
    },
    "graph_findEulerPath_stack": {
        "prefix": "graph_findEulerPath_stack",
        "body": [
            "void findEulerPath(int u)",
            "{",
            "    stack<int> st;",
            "    st.push(u);",
            "",
            "    while (!st.empty())",
            "    {",
            "        int v = st.top();",
            "        int i;",
            "        for(i = 0; i < n; ++i)",
            "            if(g[v][i] > 0)",
            "                break;",
            "        if(i == n)",
            "        {",
            "            res.push_back(v);",
            "            st.pop();",
            "        }",
            "        else",
            "        {",
            "            --g[v][i];",
            "            --g[i][v];",
            "            st.push(i);",
            "        }",
            "    }",
            "}"
        ],
        "description": "graph_findEulerPath_stack"
    },
    "dynamic_knapsack": {
        "prefix": "dynamic_knapsack",
        "body": [
            "int knapsack(int N, int W)",
            "{",
            "    dp.assign(N + 1, vector<int>(W + 1, 0));",
            "",
            "    for (int j = 0; j <= W; j++)",
            "        dp[0][j] = 0;",
            "",
            "    for (int i = 1; i <= N; i++)",
            "        for (int j = 0; j <= W; j++)",
            "        {",
            "            dp[i][j] = dp[i - 1][j];",
            "            if (j >= weight[i - 1] && dp[i][j] < dp[i - 1][j - weight[i - 1]] + profit[i - 1])",
            "            {",
            "                dp[i][j] = dp[i - 1][j - weight[i - 1]] + profit[i - 1];",
            "            }",
            "        }",
            "",
            "    return dp[N][W];",
            "}",
            "",
            "void trace(int N, int W)",
            "{",
            "    int totalWeight = 0, totalProfit = 0;",
            "    while (N > 0 && W > 0)",
            "    {",
            "        if (weight[N - 1] <= W && dp[W] == dp[W - weight[N - 1]] + profit[N - 1])",
            "        {",
            "            cout << weight[N - 1] << \" - \" << profit[N - 1] << \"\\n\";",
            "            totalWeight += weight[N - 1];",
            "            totalProfit += profit[N - 1];",
            "            W -= weight[N - 1];",
            "        }",
            "        N--;",
            "    }",
            "    cout << \"Total weight: \" << totalWeight << \"\\n\";",
            "    cout << \"Total profit: \" << totalProfit << \"\\n\";",
            "}",
            "",
            "// int knapsack(int N, int W)",
            "// {",
            "//     dp.assign(W + 1, 0);",
            "",
            "//     for(int i = 0; i < N; i++)",
            "//         for(int j = W; j >= weight[i]; j--)",
            "//         {",
            "//             if(dp[j] < dp[j - weight[i]] + profit[i])",
            "//                 dp[j] = dp[j - weight[i]] + profit[i];",
            "//         }",
            "",
            "//     return dp[W];",
            "// }"
        ],
        "description": "dynamic_knapsack"
    },
    "dynamic_lcs": {
        "prefix": "dynamic_lcs",
        "body": [
            "int lcs(vector<int> &a, vector<int> &b)",
            "{",
            "    int n = a.size();",
            "    int m = b.size();",
            "",
            "    for (int i = 0; i <= n; i++)",
            "        dp[i][0] = 0;",
            "    for (int j = 0; j <= m; j++)",
            "        dp[0][j] = 0;",
            "",
            "    for (int i = 1; i <= n; i++)",
            "        for (int j = 1; j <= m; j++)",
            "            if (a[i - 1] == b[j - 1])",
            "                dp[i][j] = dp[i - 1][j - 1] + 1;",
            "            else",
            "                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);",
            "",
            "    return dp[n][m];",
            "}",
            "",
            "void trace(vector<int>& a, vector<int>& b)",
            "{",
            "    int n = a.size(), m = b.size();",
            "",
            "    vector<int> res;",
            "    while(n > 0 && m > 0)",
            "    {",
            "        if(a[n - 1] == b[m - 1])",
            "        {",
            "            res.push_back(a[n - 1]);",
            "            n--;",
            "            m--;",
            "        }",
            "        else if(dp[n - 1][m] > dp[n][m - 1])",
            "            n--;",
            "        else",
            "            m--;",
            "    }",
            "    for(int i = res.size() - 1; i >= 0; i++)",
            "        cout << res[i] << \" \";",
            "}"
        ],
        "description": "dynamic_lcs"
    },
    "dynamic_lis": {
        "prefix": "dynamic_lis",
        "body": [
            "int LIS(vector<int>& A, vector<int>& dp, vector<int> & prev)",
            "{",
            "    int n = A.size();",
            "    vector<int> lis, lis_index;",
            "    dp.assign(n, 1);",
            "    prev.assign(n, -1);",
            "",
            "    for(int j, i = 0; i < n; i++)",
            "    {",
            "        j = upper_bound(lis.begin(), lis.end(), A[i]) - lis.begin();",
            "        dp[i] = j + 1;",
            "        if(j != 0)",
            "        {",
            "            prev[i] = lis_index[j - 1];",
            "        }",
            "        if(j == (int)lis.size())",
            "        {",
            "            lis.push_back(A[i]);",
            "            lis_index.push_back(i);",
            "        }",
            "        else",
            "        {",
            "            lis[j] = A[i];",
            "            lis_index[j] = i;",
            "        }",
            "    }",
            "",
            "    return lis_index[(int)lis.size() - 1];",
            "}",
            "",
            "void trace(vector<int>& A, vector<int>& prev, int pos)",
            "{",
            "    vector<int> b;",
            "    while(pos != -1)",
            "    {",
            "        b.push_back(A[pos]);",
            "        pos = prev[pos];",
            "    }",
            "",
            "    for(int i = (int)b.size() - 1; i >= 0; i--)",
            "        cout << b[i] << ' ';",
            "    cout << '\\n';",
            "}"
        ],
        "description": "dynamic_lis"
    },
    "numeric_segmentedSieve": {
        "prefix": "numeric_segmentedSieve",
        "body": [
            "void segmentedSieve(int l, int r, const vector<int>& basePrimes)",
            "{",
            "    isPrime.assign(r - l + 1, true);",
            "    for(int p : basePrimes)",
            "    {",
            "        int fr = ((l - 1) / p + 1) * p;",
            "        for(int j = fr; j <= r; j += p)",
            "            isPrime[j - l] = false;",
            "    }",
            "",
            "    for(int i = l; i <= r; i++)",
            "        if(isPrime[i - l]) primes.push_back(i);",
            "}"
        ],
        "description": "numeric_segmentedSieve"
    },
    "numeric_isPrime": {
        "prefix": "numeric_isPrime",
        "body": [
            "bool isPrime(int n)",
            "{",
            "    if(n < 2) return false;",
            "    for(int i = 0; i * i <= n; i++)",
            "        if(n % i == 0) return false;",
            "    return true;",
            "}"
        ],
        "description": "numeric_isPrime"
    },
    "numeric_mint": {
        "prefix": "numeric_mint",
        "body": [
            "template <int MOD>",
            "struct mint",
            "{",
            "\tint v;",
            "\texplicit operator int() const { return v; } // explicit -> don't silently convert to int",
            "\tmint() : v(0) {}",
            "\tmint(ll _v)",
            "\t{",
            "\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "\t\tif (v < 0)",
            "\t\t\tv += MOD;",
            "\t}",
            "\tfriend bool operator==(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn a.v == b.v;",
            "\t}",
            "\tfriend bool operator!=(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn !(a == b);",
            "\t}",
            "\tfriend bool operator<(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn a.v < b.v;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &o)",
            "\t{",
            "\t\tif ((v += o.v) >= MOD)",
            "\t\t\tv -= MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &o)",
            "\t{",
            "\t\tif ((v -= o.v) < 0)",
            "\t\t\tv += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &o)",
            "\t{",
            "\t\tv = int((ll)v * o.v % MOD);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }",
            "\tfriend mint pow(mint a, ll p)",
            "\t{",
            "\t\tmint ans = 1;",
            "\t\tassert(p >= 0);",
            "\t\tfor (; p; p /= 2, a *= a)",
            "\t\t\tif (p & 1)",
            "\t\t\t\tans *= a;",
            "\t\treturn ans;",
            "\t}",
            "\tfriend mint inv(const mint &a)",
            "\t{",
            "\t\tassert(a.v != 0);",
            "\t\treturn pow(a, MOD - 2);",
            "\t}",
            "",
            "\tmint operator-() const { return mint(-v); }",
            "\tmint &operator++() { return *this += 1; }",
            "\tmint &operator--() { return *this -= 1; }",
            "\tfriend mint operator+(mint a, const mint &b) { return a += b; }",
            "\tfriend mint operator-(mint a, const mint &b) { return a -= b; }",
            "\tfriend mint operator*(mint a, const mint &b) { return a *= b; }",
            "\tfriend mint operator/(mint a, const mint &b) { return a /= b; }",
            "\tfriend ostream &operator<<(ostream &os, const mint &m)",
            "\t{",
            "\t\treturn os << m.v;",
            "\t}",
            "\tfriend istream &operator>>(istream &is, mint &m)",
            "\t{",
            "\t\tll x;",
            "\t\tis >> x;",
            "\t\tm.v = x;",
            "\t\treturn is;",
            "\t}",
            "};"
        ],
        "description": "numeric_mint"
    },
    "numeric_phiEuler": {
        "prefix": "numeric_phiEuler",
        "body": [
            "int phiEuler(int n)",
            "{",
            "    int result = n;",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        if(n % i == 0)",
            "        {",
            "            while(n % i == 0) n /= i;",
            "            result = result / i * (i - 1);",
            "        }",
            "    }",
            "",
            "    if(n != 1) result = result / n * (n - 1);",
            "    return result;",
            "}"
        ],
        "description": "numeric_phiEuler"
    },
    "numeric_primeFactorization": {
        "prefix": "numeric_primeFactorization",
        "body": [
            "void primeFactorization(int n)",
            "{",
            "    cout << n << \" = \";",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        while(n % i == 0)",
            "        {",
            "            cout << i << \" \";",
            "            n /= i;",
            "        }",
            "    }",
            "",
            "    if(n != 1) cout << n;",
            "}"
        ],
        "description": "numeric_primeFactorization"
    },
    "numeric_sieveOfEratosthenes": {
        "prefix": "numeric_sieveOfEratosthenes",
        "body": [
            "void sieveOfEratosthenes(int n)",
            "{",
            "    isPrime.assign(n + 1, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    for(int i = 2; i * i <= n; i++)",
            "        if(isPrime[i])",
            "        {",
            "            for(int j = i * i; j <= n; j += i)",
            "                isPrime[j] = false;",
            "        }",
            "",
            "    for(int i = 2; i<= n; i++)",
            "        if(isPrime[i]) primes.push_back(i);",
            "}"
        ],
        "description": "numeric_sieveOfEratosthenes"
    },
    "geometry_rectangle_geometry": {
        "prefix": "geometry_rectangle_geometry",
        "body": [
            "struct Rect {",
            "\tint x1, y1, x2, y2;",
            "\tint area() { return (y2 - y1) * (x2 - x1); }",
            "};",
            "",
            "int intersect(Rect p, Rect q) {",
            "\tint xOverlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1));",
            "\tint yOverlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1));",
            "\treturn xOverlap * yOverlap;",
            "}"
        ],
        "description": "geometry_rectangle_geometry"
    },
    "data_LazySegTree": {
        "prefix": "data_LazySegTree",
        "body": [
            "template <class T>",
            "struct LazySegTree",
            "{",
            "    vector<T> seg, lazy;",
            "    int n;",
            "",
            "    LazySegTree(int n_)",
            "    {",
            "        n = n_;",
            "        seg.assign(4 * n, 0);",
            "        lazy.assign(4 * n, 0);",
            "    }",
            "",
            "    LazySegTree(const vector<T> &a) : LazySegTree((int)a.size())",
            "    {",
            "        buildTree(a, 0, 0, n - 1);",
            "    }",
            "",
            "    void buildTree(const vector<T> &a, int id, int l, int r)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        buildTree(a, 2 * id + 1, l, m);",
            "        buildTree(a, 2 * id + 2, m + 1, r);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    void down(int id, int l, int r)",
            "    {",
            "        if (l != r)",
            "        {",
            "            lazy[2 * id + 1] += lazy[id];",
            "            lazy[2 * id + 2] += lazy[id];",
            "        }",
            "        seg[id] += lazy[id];",
            "        lazy[id] = 0;",
            "    }",
            "",
            "    void lazyUpdate(int id, int l, int r, int fr, int to, T val)",
            "    {",
            "        if (lazy[id] != 0)",
            "            down(id, l, r);",
            "        if (fr > r || to < l)",
            "            return;",
            "        if (fr <= l && r <= to)",
            "        {",
            "            seg[id] += val;",
            "            if (l != r)",
            "            {",
            "                lazy[2 * id + 1] += val;",
            "                lazy[2 * id + 2] += val;",
            "            }",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        lazyUpdate(2 * id + 1, l, m, fr, to, val);",
            "        lazyUpdate(2 * id + 2, m + 1, r, fr, to, val);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    T lazyMinQuery(int id, int l, int r, int fr, int to)",
            "    {",
            "        if (lazy[id] != 0)",
            "            down(id, l, r);",
            "        if (fr > r || to < l)",
            "            return INT_MAX;",
            "        if (fr <= l && r <= to)",
            "            return seg[id];",
            "",
            "        int m = (l + r) / 2;",
            "",
            "        return min(",
            "            lazyMinQuery(2 * id + 1, l, m, fr, to),",
            "            lazyMinQuery(2 * id + 2, m + 1, r, fr, to));",
            "    }",
            "};"
        ],
        "description": "data_LazySegTree"
    },
    "data_SegTree": {
        "prefix": "data_SegTree",
        "body": [
            "template <class T>",
            "struct SegTree",
            "{",
            "    vector<T> seg;",
            "    int n;",
            "",
            "    SegTree(int n_)",
            "    {",
            "        n = n_;",
            "        seg.assign(4 * n, 0);",
            "    }",
            "",
            "    SegTree(const vector<T> &a) : SegTree((int)a.size())",
            "    {",
            "        buildTree(a, 0, 0, n - 1);",
            "    }",
            "",
            "    void buildTree(const vector<T> &a, int id, int l, int r)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        buildTree(a, 2 * id + 1, l, m);",
            "        buildTree(a, 2 * id + 2, m + 1, r);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "",
            "    T queryMin(int id, int l, int r, int fr, int to)",
            "    {",
            "        if (fr <= l && r <= to)",
            "            return seg[id];",
            "        if (fr > r || to < l)",
            "            return INT_MAX;",
            "",
            "        int m = (l + r) / 2;",
            "",
            "        return min(",
            "            queryMin(2 * id + 1, l, m, fr, to),",
            "            queryMin(2 * id + 2, m + 1, r, fr, to));",
            "    }",
            "",
            "    void updateMin(int id, int l, int r, int pos, T val)",
            "    {",
            "        if (l == r)",
            "        {",
            "            seg[id] = val;",
            "            return;",
            "        }",
            "",
            "        int m = (l + r) / 2;",
            "        if (pos <= m)",
            "            updateMin(2 * id + 1, l, m, pos, val);",
            "        else",
            "            updateMin(2 * id + 2, m + 1, r, pos, val);",
            "        seg[id] = min(seg[2 * id + 1], seg[2 * id + 2]);",
            "    }",
            "};"
        ],
        "description": "data_SegTree"
    },
    "data_indexed_set": {
        "prefix": "data_indexed_set",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template<typename T>",
            "using indexed_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;"
        ],
        "description": "data_indexed_set"
    },
    "data_dsu": {
        "prefix": "data_dsu",
        "body": [
            "struct DisjointSet",
            "{",
            "    vector<int> parent, Rank;",
            "    DisjointSet(int n): parent(n + 1), Rank(n + 1, 0)",
            "    {",
            "        for (int i=1; i<=n; i++) parent[i] = i;",
            "    }",
            "    int findSet(int u)",
            "    {",
            "        if (parent[u] != u) parent[u] = findSet(parent[u]);",
            "        return parent[u];",
            "    }",
            "    bool unionSet(int u, int v)",
            "    {",
            "        int pu = findSet(u), pv = findSet(v);",
            "        if(pu == pv) return false;",
            "        if(Rank[pu] > Rank[pv]) parent[pv] = pu;",
            "        else if(Rank[pu] < Rank[pv]) parent[pu] = pv;",
            "        else",
            "        {",
            "            parent[pv] = pu;",
            "            Rank[pu]++;",
            "        }",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "data_dsu"
    },
    "data_SparseTable_rmq": {
        "prefix": "data_SparseTable_rmq",
        "body": [
            "",
            "void compute_spare_table(const vector<T> &a)",
            "{",
            "    for (int i = 0; i < n; i++)",
            "        f[i][0] = a[i];",
            "",
            "    for (int j = 1; (1 << j) <= n; j++)",
            "    {",
            "        int step = 1 << (j - 1);",
            "        for (int i = 0; i + 2 * step <= n; i++)",
            "        {",
            "            f[i][j] = min(f[i][j - 1], f[i + step][j - 1]);",
            "        }",
            "    }",
            "}",
            "",
            "T minQuery(int l, int r)",
            "{",
            "    int k = log_2[r - l + 1];",
            "    return min(f[l][k], f[r - (1 << k) + 1][k]);",
            "}",
            "",
            "void compute_log()",
            "{",
            "    log_2[1] = 0;",
            "    for (int i = 2; i <= n; i++)",
            "    {",
            "        log_2[i] = log_2[i / 2] + 1;",
            "    }",
            "}"
        ],
        "description": "data_SparseTable_rmq"
    },
    "data_SparseTable_init": {
        "prefix": "data_SparseTable_init",
        "body": [
            "template <class T>",
            "struct SparseTable",
            "{",
            "    int n_log, n; // 2^MAX_LOG >= n",
            "    vector<vector<T>> f;",
            "    vector<T> log_2;",
            "",
            "    SparseTable(int n_)",
            "    {",
            "        n = n_;",
            "        n_log = ceil(log2(n));",
            "        f.assign(n, vector<T> (n_log + 1, 0));",
            "        log_2.assign(n_log + 1, 0);",
            "    }",
            "",
            "",
            "};"
        ],
        "description": "data_SparseTable_init"
    },
    "data_SparseTable_rsq": {
        "prefix": "data_SparseTable_rsq",
        "body": [
            "void compute_spare_table(const vector<T> &a)",
            "{",
            "    for (int i = 0; i < n; i++)",
            "        f[i][0] = a[i];",
            "",
            "    for (int j = 1; (1 << j) <= n; j++)",
            "    {",
            "        int step = 1 << (j - 1);",
            "        for (int i = 0; i + 2 * step <= n; i++)",
            "        {",
            "            f[i][j] = f[i][j - 1] + f[i + step][j - 1];",
            "        }",
            "    }",
            "}",
            "",
            "T sumQuery(int l, int r)",
            "{",
            "    int k, total = 0;",
            "    for (int k = n_log; k >= 0; k--)",
            "    {",
            "        if (l + (1 << k) - 1 <= r)",
            "        {",
            "            total += f[l][k];",
            "            l += 1 << k;",
            "        }",
            "    }",
            "    return total;",
            "}",
            "",
            "void compute_log()",
            "{",
            "    log_2[1] = 0;",
            "    for (int i = 2; i <= n; i++)",
            "    {",
            "        log_2[i] = log_2[i / 2] + 1;",
            "    }",
            "}"
        ],
        "description": "data_SparseTable_rsq"
    },
    "data_FenwickTree_range_range": {
        "prefix": "data_FenwickTree_range_range",
        "body": [
            "int n;",
            "vector<T> f1, f2;",
            "",
            "FenwickTree(int n_)",
            "{",
            "    n = n_;",
            "    f1.assign(n + 7, 0);",
            "    f2.assign(n + 7, 0);",
            "}",
            "",
            "void update(vector<T> &f, int id, int val)",
            "{",
            "    while(id <= n)",
            "    {",
            "        f[id] += val;",
            "        id += id & -id;",
            "    }",
            "}",
            "",
            "T getSum(vector<T> &f, int id)",
            "{",
            "    T sum = 0;",
            "    while(id > 0)",
            "    {",
            "        sum += f[id];",
            "        id -= id & -id;",
            "    }",
            "    return sum;",
            "}",
            "",
            "void updateRange(int l, int r, T val)",
            "{",
            "    update(f1, l, val);",
            "    update(f1, r + 1, -val);",
            "    update(f2, l, val *(l - 1));",
            "    update(f2, r + 1, -val * r);",
            "}",
            "",
            "T prefixSum(int id)",
            "{",
            "    return getSum(f1, id) * id - getSum(f2, id);",
            "}",
            "",
            "T sumRange(int l, int r)",
            "{",
            "    return prefixSum(r) - prefixSum(l - 1);",
            "}"
        ],
        "description": "data_FenwickTree_range_range"
    },
    "data_FenwickTree_point_range": {
        "prefix": "data_FenwickTree_point_range",
        "body": [
            "int n;",
            "vector<T> f;",
            "",
            "FenwickTree(int n_)",
            "{",
            "    n = n_;",
            "    f.assign(n + 7, 0);",
            "}",
            "",
            "void update(int id, int val)",
            "{",
            "    while(id <= n)",
            "    {",
            "        f[id] += val;",
            "        id += id & -id;",
            "    }",
            "}",
            "",
            "T getSum(int id)",
            "{",
            "    T sum = 0;",
            "    while(id > 0)",
            "    {",
            "        sum += f[id];",
            "        id -= id & -id;",
            "    }",
            "    return sum;",
            "}",
            "",
            "T sumRange(int l, int r)",
            "{",
            "    return getSum(r) - getSum(l);",
            "}",
            "",
            "void updateRange (int l, int r, T val)",
            "{",
            "    update(l, val);",
            "    update(r + 1, -val);",
            "}"
        ],
        "description": "data_FenwickTree_point_range"
    },
    "data_FenwickTree_init": {
        "prefix": "data_FenwickTree_init",
        "body": [
            "template <class T>",
            "struct FenwickTree",
            "{",
            "",
            "};"
        ],
        "description": "data_FenwickTree_init"
    }
}