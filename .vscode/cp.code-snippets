{
    "rectangle_geometry": {
        "prefix": "rectangle_geometry",
        "body": [
            "struct Rect {",
            "\tint x1, y1, x2, y2;",
            "\tint area() { return (y2 - y1) * (x2 - x1); }",
            "};",
            "",
            "int intersect(Rect p, Rect q) {",
            "\tint xOverlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1));",
            "\tint yOverlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1));",
            "\treturn xOverlap * yOverlap;",
            "}"
        ],
        "description": "rectangle_geometry"
    },
    "bellmanFord": {
        "prefix": "bellmanFord",
        "body": [
            "int bellmanFord(vector<Edge> &edges, int n, int m, int s)",
            "{",
            "    dist.assign(n + 1, INF);",
            "    path.assign(n + 1, -1);",
            "    dist[s] = 0;",
            "    int u, v, w;",
            "    for(int i = 1; i < n; i++)",
            "    {",
            "        for(int j = 0; j < m; j++)",
            "        {",
            "            u = edges[j].u;",
            "            v = edges[j].v;",
            "            w = edges[j].w;",
            "            if(dist[u] != INF && dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "            }",
            "        }",
            "    }",
            "    for(int j = 0; j < m; j++)",
            "    {",
            "        u = edges[j].u;",
            "        v = edges[j].v;",
            "        w = edges[j].w;",
            "        if(dist[u] != INF && dist[v] > dist[u] + w)",
            "        {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "bellmanFord"
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "void bfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    queue<int> q;",
            "",
            "    q.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!q.empty())",
            "    {",
            "        u = q.front();",
            "        q.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                q.push(v);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "bfs"
    },
    "bridgeCutVertex_recursive": {
        "prefix": "bridgeCutVertex_recursive",
        "body": [
            "void bridgeCutVertex_recursive(int u, int p)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    int numChild = 0;",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(v == p) continue;",
            "        if(num[v] > 0)",
            "            low[u] = min(low[u], num[v]);",
            "        else",
            "        {",
            "            bridgeCutVertex_recursive(v, u);",
            "            low[u] = min(low[u], low[v]);",
            "            numChild++;",
            "            if(low[v] > num[u])",
            "                bridge.push_back(make_pair(u, v));",
            "            if(low[v] >= num[u] && p != -1)",
            "                isCut[u] = true;",
            "        }",
            "    }",
            "    if(p == -1 && numChild > 1)",
            "        isCut[u] = true;",
            "}"
        ],
        "description": "bridgeCutVertex_recursive"
    },
    "dfs_recursive": {
        "prefix": "dfs_recursive",
        "body": [
            "void dfs(int s)",
            "{",
            "    visited[s] = true;",
            "",
            "    for(int i = 0; i < (int)adj[s].size(); i++)",
            "    {",
            "        int v = adj[s][i];",
            "",
            "        if(!visited[v])",
            "        {",
            "            path[v] = s;",
            "            dfs(v);",
            "        }",
            "    }",
            "}"
        ],
        "description": "dfs_recursive"
    },
    "dfs_stack": {
        "prefix": "dfs_stack",
        "body": [
            "void dfs(int s)",
            "{",
            "    int sz = adj.size();",
            "    path.assign(sz, -1);",
            "    visited.assign(sz, false);",
            "    stack<int> st;",
            "",
            "    st.push(s);",
            "    visited[s] = true;",
            "",
            "    int u, v;",
            "    while(!st.empty())",
            "    {",
            "        u = st.top();",
            "        st.pop();",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i];",
            "            if(!visited[v])",
            "            {",
            "                visited[v] = true;",
            "                path[v] = u;",
            "                st.push(v);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "dfs_stack"
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "void dijkstra(int s)",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, s});",
            "    dist[s] = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(tmp.first != dist[u]) continue;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(dist[v] > dist[u] + w)",
            "            {",
            "                dist[v] = dist[u] + w;",
            "                path[v] = u;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "dijkstra"
    },
    "Edge": {
        "prefix": "Edge",
        "body": [
            "struct Edge",
            "{",
            "    int u, v, w;",
            "    Edge(int u = 0, int v = 0, int w = 0)",
            "        : u(u), v(v), w(w) {}",
            "    bool operator<(const Edge& other) const",
            "    {",
            "        return w < other.w;",
            "    }",
            "};"
        ],
        "description": "Edge"
    },
    "findEulerCycle": {
        "prefix": "findEulerCycle",
        "body": [
            "void findEulerCycle()",
            "{",
            "    int u = -1, v = -1;",
            "    bool isConnected = true, bad = false;",
            "",
            "    for(int i = 0; i < n; i++)",
            "    {",
            "        int cnt = 0;",
            "        for(int j = 0; j < n; j++)",
            "            cnt += g[i][j];",
            "",
            "        if(cnt % 2 == 1)",
            "        {",
            "            if(u == -1)",
            "                u = i;",
            "            else if(v == -1)",
            "                v = i;",
            "            else",
            "            {",
            "                bad = true;",
            "                break;",
            "            }",
            "        }",
            "    }",
            "",
            "    if(bad)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u != -1)",
            "    {",
            "        g[u][v]++; g[v][u]++;",
            "        m++;",
            "    }",
            "    findEulerPath(0);",
            "    if((int)result.size() != m + 1)",
            "    {",
            "        cout << \"Graph does not have Euler Path\";",
            "        return;",
            "    }",
            "    if(u == -1)",
            "    {",
            "        cout << \"Euler cycle: \";",
            "        for(int v : result)",
            "            cout << v << \" \";",
            "        return;",
            "    }",
            "",
            "    for(int i = 0; i < (int)result.size(); i++)",
            "    {",
            "        if((result[i] == u && result[i + 1] == v) || (result[i] == v && result[i + 1] == u))",
            "        {",
            "            for(int j = 1; j <= i; j++)",
            "                result.push_back(result[j]);",
            "            result.erase(result.begin(), result.begin() + i + 1);",
            "            break;",
            "        }",
            "    }",
            "",
            "    cout << \"Euler Path: \"",
            "    for(int v : result)",
            "        cout << v << \" \";",
            "}"
        ],
        "description": "findEulerCycle"
    },
    "findEulerPath_recursive": {
        "prefix": "findEulerPath_recursive",
        "body": [
            "void findEulerPath_recursive(int u)",
            "{",
            "    for(int v = 0; v < n; v++)",
            "    {",
            "        if(g[u][v] > 0)",
            "        {",
            "            g[u][v]--;",
            "            g[v][u]--;",
            "            findEulerPath_recursive(v);",
            "        }",
            "    }",
            "    result.push_back(u);",
            "}"
        ],
        "description": "findEulerPath_recursive"
    },
    "findEulerPath_stack": {
        "prefix": "findEulerPath_stack",
        "body": [
            "void findEulerPath_stack(int u)",
            "{",
            "    stack<int> st;",
            "    st.push(u);",
            "",
            "    while (!st.empty())",
            "    {",
            "        int v = st.top();",
            "        int i;",
            "        for(i = 0; i < n; ++i)",
            "            if(g[v][i] > 0)",
            "                break;",
            "        if(i == n)",
            "        {",
            "            res.push_back(v);",
            "            st.pop();",
            "        }",
            "        else",
            "        {",
            "            --g[v][i];",
            "            --g[i][v];",
            "            st.push(i);",
            "        }",
            "    }",
            "}"
        ],
        "description": "findEulerPath_stack"
    },
    "findHamiltonPath": {
        "prefix": "findHamiltonPath",
        "body": [
            "void findHamiltonPath(int u)",
            "{",
            "    if((int)path.size()== n)",
            "    {",
            "        bool hasCycle = false;",
            "        for(int v : graph[u])",
            "            if(v == path[0])",
            "            {",
            "                hasCycle = true;",
            "                break;",
            "            }",
            "        if(hasCycle)",
            "            cout << \"found a Hamilton cycle\";",
            "        else",
            "            cout << \"found a Hamilton path\";",
            "        return;",
            "    }",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!visited[v])",
            "        {",
            "            visited[v] = true;",
            "            path.push_back(v);",
            "            findHamiltonPath(v);",
            "            path.pop_back();",
            "            visited[v] = false;",
            "        }",
            "    }",
            "}"
        ],
        "description": "findHamiltonPath"
    },
    "floyWarshall": {
        "prefix": "floyWarshall",
        "body": [
            "int floydWarshall(vector<vector<int>> &matrix, int n)",
            "{",
            "    dist.assign(n + 1, vector<int>(n + 1));",
            "    path.assign(n + 1, vector<int>(n + 1));",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        for(int j = 1; j <= n; j++)",
            "        {",
            "            dist[i][j] = i == j ? 0 : matrix[i][j];",
            "            if(i != j && dist[i][j] < INF)",
            "            {",
            "                path[i][j] = i;",
            "            }",
            "            else",
            "            {",
            "                path[i][j] = -1;",
            "            }",
            "        }",
            "    }",
            "    for(int k = 1; k <= n; k++)",
            "    {",
            "        for(int i = 1; i <= n; i++)",
            "        {",
            "            if(dist[i][k] >= INF) continue;",
            "            for(int j = 1; j <= n; j++)",
            "            {",
            "                if(dist[k][j] < INF && dist[i][j] > dist[i][k] + dist[k][j])",
            "                {",
            "                    dist[i][j] = dist[i][k] + dist[k][j];",
            "                    path[i][j] = path[k][j];",
            "                }",
            "            }",
            "        }",
            "    }",
            "    // check negative cycle",
            "    for(int i = 1; i <= n; i++)",
            "    {",
            "        if(dist[i][j] < 0) return false;",
            "    }",
            "}"
        ],
        "description": "floyWarshall"
    },
    "Graph": {
        "prefix": "Graph",
        "body": [
            "struct Graph",
            "{",
            "",
            "",
            "    Graph()",
            "    {}",
            "",
            "};"
        ],
        "description": "Graph"
    },
    "kahn": {
        "prefix": "kahn",
        "body": [
            "bool kahn()",
            "{",
            "    queue<int> q;",
            "    for(int i = 1; i <= n; i++)",
            "        if(indegree[i] == 0)",
            "            q.push(i);",
            "    while(!q.empty())",
            "    {",
            "        int u = q.front(); q.pop();",
            "        result.push_back(u);",
            "        for(int i = 0; i < (int)graph[u].size(); i++)",
            "        {",
            "            indegree[graph[u][i]]--;",
            "            if(indegree[graph[u][i]] == 0)",
            "            {",
            "                q.push(graph[u][i]);",
            "            }",
            "        }",
            "    }",
            "    return result.size() == n;",
            "}"
        ],
        "description": "kahn"
    },
    "kruskal": {
        "prefix": "kruskal",
        "body": [
            "int kruskal()",
            "{",
            "    int mst = 0;",
            "    int cnt = 0;",
            "",
            "    sort(edges.begin(), edges.end());",
            "    DisjointSet djs(n);",
            "",
            "    for(int u, v, w, i = 0; i < m; i++)",
            "    {",
            "        u = edges[i].u;",
            "        v = edges[i].v;",
            "        w = edges[i].w;",
            "",
            "        if(djs.unionSet(u, v))",
            "        {",
            "            cnt++;",
            "            mst += w;",
            "        }",
            "    }",
            "    return cnt == n - 1 ? mst : -1;",
            "}"
        ],
        "description": "kruskal"
    },
    "prim": {
        "prefix": "prim",
        "body": [
            "bool prim()",
            "{",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    visited.assign(n, false);",
            "",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, 0});",
            "    dist[0] = 0;",
            "",
            "    int count = 0;",
            "    while(!pq.empty())",
            "    {",
            "        pii tmp = pq.top(); pq.pop();",
            "        int u = tmp.second;",
            "        if(visited[u]) continue;",
            "        visited[u] = true;",
            "        count++;",
            "        for(int i = 0; i < (int)adj[u].size(); i++)",
            "        {",
            "            int v = adj[u][i].first;",
            "            int w = adj[u][i].second;",
            "            if(!visited[v] && dist[v] > w)",
            "            {",
            "                dist[v] = w;",
            "                path[v] = u;",
            "                pq.push({w, v});",
            "            }",
            "        }",
            "    }",
            "    return count == n;",
            "}"
        ],
        "description": "prim"
    },
    "tarjan": {
        "prefix": "tarjan",
        "body": [
            "void tarjan(int u)",
            "{",
            "    counter++;",
            "    num[u] = low[u] = counter;",
            "    st.push(u);",
            "",
            "    for(int v : graph[u])",
            "    {",
            "        if(!found[v])",
            "        {",
            "            if(num[v] > 0)",
            "                low[u] = min(low[u], num[v]);",
            "            else",
            "            {",
            "                dfs_tarjan(v);",
            "                low[u] = min(low[u], low[v]);",
            "            }",
            "        }",
            "    }",
            "    if(num[u] == low[u])",
            "    {",
            "        cout << \"Found a SCC:\";",
            "        int v;",
            "        do",
            "        {",
            "            v = st.top();",
            "            st.pop();",
            "            cout << \" \" << v;",
            "            found[v] = true;",
            "        } while(v != u);",
            "        cout << \"\\n\";",
            "    }",
            "}"
        ],
        "description": "tarjan"
    },
    "topo_dfs": {
        "prefix": "topo_dfs",
        "body": [
            "bool topo_dfs(int u)",
            "{",
            "    visited[u] = 1;",
            "    for(int i = 0; i < (int)graph[u].size(); i++)",
            "    {",
            "        if(visited[graph[u][i]] == 1)",
            "        {",
            "            return false;",
            "        }",
            "        if(visited[graph[u][i]] == 0)",
            "        {",
            "            if(topo_dfs(graph[u][i]) == false)",
            "                return false;",
            "        }",
            "    }",
            "    result.push_back(u);",
            "    visited[u] = 2;",
            "    return true;",
            "}"
        ],
        "description": "topo_dfs"
    },
    "debug": {
        "prefix": "debug",
        "body": [
            "void __print(int x) {cerr << x;}",
            "void __print(long x) {cerr << x;}",
            "void __print(long long x) {cerr << x;}",
            "void __print(unsigned x) {cerr << x;}",
            "void __print(unsigned long x) {cerr << x;}",
            "void __print(unsigned long long x) {cerr << x;}",
            "void __print(float x) {cerr << x;}",
            "void __print(double x) {cerr << x;}",
            "void __print(long double x) {cerr << x;}",
            "void __print(char x) {cerr << '\\'' << x << '\\'';}",
            "void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
            "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
            "",
            "template<typename T, typename V>",
            "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}",
            "template<typename T>",
            "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}",
            "void _print() {cerr << \"]\\n\";}",
            "template <typename T, typename... V>",
            "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
            "",
            "#define dbg(...) cerr<<__func__<<\":\"<<__LINE__<<\" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__);"
        ],
        "description": "debug"
    },
    "isPrime": {
        "prefix": "isPrime",
        "body": [
            "bool isPrime(int n)",
            "{",
            "    if(n < 2) return false;",
            "    for(int i = 0; i * i <= n; i++)",
            "        if(n % i == 0) return false;",
            "    return true;",
            "}"
        ],
        "description": "isPrime"
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "template <int MOD>",
            "struct mint",
            "{",
            "\tint v;",
            "\texplicit operator int() const { return v; } // explicit -> don't silently convert to int",
            "\tmint() : v(0) {}",
            "\tmint(ll _v)",
            "\t{",
            "\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "\t\tif (v < 0)",
            "\t\t\tv += MOD;",
            "\t}",
            "\tfriend bool operator==(const mi &a, const mi &b)",
            "\t{",
            "\t\treturn a.v == b.v;",
            "\t}",
            "\tfriend bool operator!=(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn !(a == b);",
            "\t}",
            "\tfriend bool operator<(const mint &a, const mint &b)",
            "\t{",
            "\t\treturn a.v < b.v;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &o)",
            "\t{",
            "\t\tif ((v += o.v) >= MOD)",
            "\t\t\tv -= MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &o)",
            "\t{",
            "\t\tif ((v -= o.v) < 0)",
            "\t\t\tv += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &o)",
            "\t{",
            "\t\tv = int((ll)v * o.v % MOD);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }",
            "\tfriend mint pow(mint a, ll p)",
            "\t{",
            "\t\tmint ans = 1;",
            "\t\tassert(p >= 0);",
            "\t\tfor (; p; p /= 2, a *= a)",
            "\t\t\tif (p & 1)",
            "\t\t\t\tans *= a;",
            "\t\treturn ans;",
            "\t}",
            "\tfriend mint inv(const mint &a)",
            "\t{",
            "\t\tassert(a.v != 0);",
            "\t\treturn pow(a, MOD - 2);",
            "\t}",
            "",
            "\tmint operator-() const { return mint(-v); }",
            "\tmint &operator++() { return *this += 1; }",
            "\tmint &operator--() { return *this -= 1; }",
            "\tfriend mint operator+(mint a, const mint &b) { return a += b; }",
            "\tfriend mint operator-(mint a, const mint &b) { return a -= b; }",
            "\tfriend mint operator*(mint a, const mint &b) { return a *= b; }",
            "\tfriend mint operator/(mint a, const mint &b) { return a /= b; }",
            "\tfriend ostream &operator<<(ostream &os, const mi &m)",
            "\t{",
            "\t\treturn os << m.v;",
            "\t}",
            "\tfriend istream &operator>>(istream &is, mi &m)",
            "\t{",
            "\t\tll x;",
            "\t\tis >> x;",
            "\t\tm.v = x;",
            "\t\treturn is;",
            "\t}",
            "};"
        ],
        "description": "mint"
    },
    "phiEuler": {
        "prefix": "phiEuler",
        "body": [
            "int phiEuler(int n)",
            "{",
            "    int result = n;",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        if(n % i == 0)",
            "        {",
            "            while(n % i == 0) n /= i;",
            "            result = result / i * (i - 1);",
            "        }",
            "    }",
            "",
            "    if(n != 1) result = result / n * (n - 1);",
            "    return result;",
            "}"
        ],
        "description": "phiEuler"
    },
    "primeFactorization": {
        "prefix": "primeFactorization",
        "body": [
            "void primeFactorization(int n)",
            "{",
            "    cout << n << \" = \";",
            "    for(int i = 2; i * i <= n; i++)",
            "    {",
            "        while(n % i == 0)",
            "        {",
            "            cout << i << \" \";",
            "            n /= i;",
            "        }",
            "    }",
            "",
            "    if(n != 1) cout << n;",
            "}"
        ],
        "description": "primeFactorization"
    },
    "segmentedSieve": {
        "prefix": "segmentedSieve",
        "body": [
            "void segmentedSieve(int l, int r, const vector<int>& basePrimes)",
            "{",
            "    isPrime.assign(r - l + 1, true);",
            "    for(int p : basePrimes)",
            "    {",
            "        int fr = ((l - 1) / p + 1) * p;",
            "        for(int j = fr; j <= r; j += p)",
            "            isPrime[j - l] = false;",
            "    }",
            "",
            "    for(int i = l; i <= r; i++)",
            "        if(isPrime[i - l]) primes.push_back(i);",
            "}"
        ],
        "description": "segmentedSieve"
    },
    "sieveOfEratosthenes": {
        "prefix": "sieveOfEratosthenes",
        "body": [
            "void sieveOfEratosthenes(int n)",
            "{",
            "    isPrime.assign(n + 1, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    for(int i = 2; i * i <= n; i++)",
            "        if(isPrime[i])",
            "        {",
            "            for(int j = i * i; j <= n; j += i)",
            "                isPrime[j] = false;",
            "        }",
            "",
            "    for(int i = 2; i<= n; i++)",
            "        if(isPrime[i]) primes.push_back(i);",
            "}"
        ],
        "description": "sieveOfEratosthenes"
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "struct DisjointSet",
            "{",
            "    vector<int> parent, Rank;",
            "    DisjointSet(int n): parent(n + 1), Rank(n + 1, 0)",
            "    {",
            "        for (int i=1; i<=n; i++) parent[i] = i;",
            "    }",
            "    int findSet(int u)",
            "    {",
            "        if (parent[u] != u) parent[u] = findSet(parent[u]);",
            "        return parent[u];",
            "    }",
            "    bool unionSet(int u, int v)",
            "    {",
            "        int pu = findSet(u), pv = findSet(v);",
            "        if(pu == pv) return false;",
            "        if(Rank[pu] > Rank[pv]) parent[pv] = pu;",
            "        else if(Rank[pu] < Rank[pv]) parent[pu] = pv;",
            "        else",
            "        {",
            "            parent[pv] = pu;",
            "            Rank[pu]++;",
            "        }",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "dsu"
    },
    "indexed_set": {
        "prefix": "indexed_set",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template<typename T>",
            "using indexed_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;"
        ],
        "description": "indexed_set"
    },
    "gfg": {
        "prefix": "gfg",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "",
            "void solve()",
            "{",
            "",
            "}",
            "",
            "int main()",
            "{",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(NULL);",
            "",
            "    int t = 1;",
            "    cin >> t;",
            "",
            "    while(t--)",
            "        solve();",
            "",
            "    return 0;",
            "}"
        ],
        "description": "gfg"
    }
}