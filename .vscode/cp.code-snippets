{
	// Place your code workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"template": {
    	"prefix": "gfg",
    	"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;\n",
			"typedef long long ll;",
			"typedef pair<int, int> pii;\n",
			"const int MOD = 1000000007;\n",
			"void solve()",
			"{",
			"\t$0",
			"}\n",
			
			"int main()",
			"{",
				"\tios::sync_with_stdio(false);",
				"\tcin.tie(NULL);\n",
				
				"\tint t = 1;",
				"\tcin >> t;\n",

				"\twhile(t--)",
				"\t{",
					"\t\tsolve();",
				"\t}\n",

				"\treturn 0;",
          	"}"
        ],
        "description": "template"
    },
	"debug": {
    	"prefix": "debug",
    	"body": [
			"\nvoid __print(int x) {cerr << x;}",
			"void __print(long x) {cerr << x;}",
			"void __print(long long x) {cerr << x;}",
			"void __print(unsigned x) {cerr << x;}",
			"void __print(unsigned long x) {cerr << x;}",
			"void __print(unsigned long long x) {cerr << x;}",
			"void __print(float x) {cerr << x;}",
			"void __print(double x) {cerr << x;}",
			"void __print(long double x) {cerr << x;}",
			"void __print(char x) {cerr << '\\'' << x << '\\'';}",
			"void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
			"void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
			"void __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n",
			"template<typename T, typename V>",
			"void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}",
			"template<typename T>",
			"void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}",
			"void _print() {cerr << \"]\\n\";}",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",

			"#define dbg(...) cerr<<__func__<<\":\"<<__LINE__<<\" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__);\n",
        ],
        "description": "debug"
    },
	"orderSet": {
    	"prefix": "orderSet",
    	"body": [
			"\n#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
 			"typedef __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> ordered_set;\n",
        ],
        "description": "orderSet"
    },
	"bfs": {
    	"prefix": "bfs",
    	"body": [
			"\nvoid bfs(int s)",
			"{",
				"\tint sz = adj.size();",
				"\tpath.assign(sz, -1);",
				"\tvisited.assign(sz, false);",
				"\tqueue<int> q;",

				"\n\tq.push(s);",
				"\tvisited[s] = true;",

				"\n\tint u, v;",
				"\twhile(!q.empty())",
				"\t{",
					"\t\tu = q.front();",
					"\t\tq.pop();",

					"\t\tfor(int i = 0; i < (int)adj[u].size(); i++)",
					"\t\t{",
						"\t\t\tint v = adj[u][i];",
						"\t\t\tif(!visited[v])",
						"\t\t\t{",
							"\t\t\t\tvisited[v] = true;",
							"\t\t\t\tpath[v] = u;",
							"\t\t\t\tq.push(v);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "bfs"
    },
	"dfs_stack": {
    	"prefix": "dfs_stack",
    	"body": [
			"\nvoid dfs(int s)",
			"{",
				"\tint sz = adj.size();",
				"\tpath.assign(sz, -1);",
				"\tvisited.assign(sz, false);",
				"\tstack<int> st;",

				"\n\tst.push(s);",
				"\tvisited[s] = true;",

				"\n\tint u, v;",
				"\twhile(!st.empty())",
				"\t{",
					"\t\tu = st.top();",
					"\t\tst.pop();",

					"\t\tfor(int i = 0; i < (int)adj[u].size(); i++)",
					"\t\t{",
						"\t\t\tint v = adj[u][i];",
						"\t\t\tif(!visited[v])",
						"\t\t\t{",
							"\t\t\t\tvisited[v] = true;",
							"\t\t\t\tpath[v] = u;",
							"\t\t\t\tst.push(v);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "dfs with stack"
    },
	"dfs_recursive": {
    	"prefix": "dfs_recursive",
    	"body": [
			"\nvoid dfs(int s)",
			"{",
				"\tvisited[s] = true;",

				"\n\tfor(int i = 0; i < (int)adj[s].size(); i++)",
				"\t{",
					"\t\tint v = adj[s][i];",

					"\n\t\tif(!visited[v])",
					"\t\t{",
						"\t\t\tpath[v] = s;",
						"\t\t\tdfs(v);",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "dfs with recursive"
    },
	"dijkstra": {
    	"prefix": "dijkstra",
    	"body": [
			"\nvoid dijkstra(int s)",
			"{",
				"\tdist.assign(n, INF);",
				"\tpath.assign(n, -1);",
				"\tpriority_queue<pii, vector<pii>, greater<pii>> pq;",
				"\tpq.push({0, s});",
				"\tdist[s] = 0;",

				"\twhile(!pq.empty())",
				"\t{",
					"\t\tpii tmp = pq.top(); pq.pop();",

					"\t\tint u = tmp.second;",
					"\t\tif(tmp.first != dist[u]) continue;",

					"\t\tfor(int i = 0; i < (int)adj[u].size(); i++)",
					"\t\t{",
						"\t\t\tint v = adj[u][i].first;",
						"\t\t\tint w = adj[u][i].second;",
						"\t\t\tif(dist[v] > dist[u] + w)",
						"\t\t\t{",
							"\t\t\t\tdist[v] = dist[u] + w;",
							"\t\t\t\tpath[v] = u;",
							"\t\t\t\tpq.push({dist[v], v});",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
        ],
        "description": "dijkstra"
    },
	"bellmanFord": {
    	"prefix": "bellmanFord",
    	"body": [
			"\nint bellmanFord(vector<Edge> &edges, int n, int m, int s)",
			"{",
				"\tdist.assign(n + 1, INF);",
				"\tpath.assign(n + 1, -1);",
				"\tdist[s] = 0;",

				"\tint u, v, w;",
				"\tfor(int i = 1; i < n; i++)",
				"\t{",
					"\t\tfor(int j = 0; j < m; j++)",
					"\t\t{",

						"\t\t\tu = edges[j].u;",
						"\t\t\tv = edges[j].v;",
						"\t\t\tw = edges[j].w;",
						"\t\t\tif(dist[u] != INF && dist[v] > dist[u] + w)",
						"\t\t\t{",
							"\t\t\t\tdist[v] = dist[u] + w;",
							"\t\t\t\tpath[v] = u;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tfor(int j = 0; j < m; j++)",
				"\t{",
					"\t\tu = edges[j].u;",
					"\t\tv = edges[j].v;",
					"\t\tw = edges[j].w;",
					"\t\tif(dist[u] != INF && dist[v] > dist[u] + w)",
					"\t\t{",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",

				"\treturn true;",
			"}",
        ],
        "description": "bellmanFord"
    },
	"floydWarshall": {
    	"prefix": "floydWarshall",
    	"body": [
			"\nint floydWarshall(vector<vector<int>> &matrix, int n)",
			"{",
				"\tdist.assign(n + 1, vector<int>(n + 1));",
				"\tpath.assign(n + 1, vector<int>(n + 1));",

				"\tfor(int i = 1; i <= n; i++)",
				"\t{",
					"\t\tfor(int j = 1; j <= n; j++)",
					"\t\t{",

						"\t\t\tdist[i][j] = i == j ? 0 : matrix[i][j];",
						"\t\t\tif(i != j && dist[i][j] < INF)",
						"\t\t\t{",
							"\t\t\t\tpath[i][j] = i;",
						"\t\t\t}",
						"\t\t\telse",
						"\t\t\t{",
							"\t\t\t\tpath[i][j] = -1;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tfor(int k = 1; k <= n; k++)",
				"\t{",
					"\t\tfor(int i = 1; i <= n; i++)",
					"\t\t{",

						"\t\t\tif(dist[i][k] >= INF) continue;",
						"\t\t\tfor(int j = 1; j <= n; j++)",
						"\t\t\t{",
							"\t\t\t\tif(dist[k][j] < INF && dist[i][j] > dist[i][k] + dist[k][j])",
							"\t\t\t\t{",
								"\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];",
								"\t\t\t\t\tpath[i][j] = path[k][j];",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",

				"\t// check negative cycle",
				"\tfor(int i = 1; i <= n; i++)",
				"\t{",
					"\t\tif(dist[i][j] < 0) return false;",
				"\t}",
			"}",
        ],
        "description": "floydWarshall"
    },
	"dfs_topo": {
    	"prefix": "dfs_topo",
    	"body": [
			"\nbool dfs_topo(int u)",
			"{",
				"\tvisited[u] = 1;",
				"\tfor(int i = 0; i < (int)graph[u].size(); i++)",
				"\t{",

					"\t\tif(visited[graph[u][i]] == 1)",
					"\t\t{",
						"\t\t\treturn false;",
					"\t\t}",
					"\t\tif(visited[graph[u][i]] == 0)",
					"\t\t{",
						"\t\t\tif(dfs_topo(graph[u][i]) == false)",
							"\t\t\t\treturn false;",
					"\t\t}",
				"\t}",
				"\tresult.push_back(u);",
				"\tvisited[u] = 2;",
				"\treturn true;",
			"}",
        ],
        "description": "dfs_topo"
    },
	"kahn": {
    	"prefix": "kahn",
    	"body": [
			"\nbool kahn()",
			"{",
				"\tqueue<int> q;",
				"\tfor(int i = 1; i <= n; i++)",
					"\t\tif(indegree[i] == 0)",
						"\t\t\tq.push(i);",
				
				"\twhile(!q.empty())",
				"\t{",
					"\t\tint u = q.front(); q.pop();",

					"\t\tresult.push_back(u);",

					"\t\tfor(int i = 0; i < (int)graph[u].size(); i++)",
					"\t\t{",
						"\t\t\tindegree[graph[u][i]]--;",
						"\t\t\tif(indegree[graph[u][i]] == 0)",
						"\t\t\t{",
							"\t\t\t\tq.push(graph[u][i]);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\treturn result.size() == n;",
			"}",
        ],
        "description": "kahn"
    },
	"prim": {
    	"prefix": "prim",
    	"body": [
			"\nbool prim()",
			"{",
				"\tdist.assign(n, INF);",
				"\tpath.assign(n, -1);",
				"\tvisited.assign(n, false);\n",

				"\tpriority_queue<pii, vector<pii>, greater<pii>> pq;",
				"\tpq.push({0, 0});",
				"\tdist[0] = 0;\n",

				"\tint count = 0;",

				"\twhile(!pq.empty())",
				"\t{",
					"\t\tpii tmp = pq.top(); pq.pop();",

					"\t\tint u = tmp.second;",
					"\t\tif(visited[u]) continue;",
					"\t\tvisited[u] = true;",
					"\t\tcount++;",

					"\t\tfor(int i = 0; i < (int)adj[u].size(); i++)",
					"\t\t{",
						"\t\t\tint v = adj[u][i].first;",
						"\t\t\tint w = adj[u][i].second;",
						"\t\t\tif(!visited[v] && dist[v] > w)",
						"\t\t\t{",
							"\t\t\t\tdist[v] = w;",
							"\t\t\t\tpath[v] = u;",
							"\t\t\t\tpq.push({w, v});",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\treturn count == n;",
			"}",
        ],
        "description": "prim"
    },
	"kruskal": {
    	"prefix": "kruskal",
    	"body": [
			"\nint kruskal()",
			"{",
				"\tint mst = 0;",
				"\tint cnt = 0;\n",

				"\tsort(edges.begin(), edges.end());",
				"\tDisjointSet djs(n);\n",

				"\tfor(int u, v, w, i = 0; i < m; i++)",
				"\t{",
					"\t\tu = edges[i].u;",
					"\t\tv = edges[i].v;",
					"\t\tw = edges[i].w;\n",

					"\t\tif(djs.unionSet(u, v))",
					"\t\t{",
						"\t\t\tcnt++;",
						"\t\t\tmst += w;",
					"\t\t}",
				"\t}",
				"\treturn cnt == n - 1 ? mst : -1;",
			"}",
        ],
        "description": "kruskal"
    },
	"dfs_tarjan": {
    	"prefix": "dfs_tarjan",
    	"body": [
			"\nvoid dfs_tarjan(int u)",
			"{",
				"\tcounter++;",
				"\tnum[u] = low[u] = counter;",
				"\tst.push(u);\n",

				"\tfor(int v : graph[u])",
				"\t{",
					"\t\tif(!found[v])",
					"\t\t{",
						"\t\t\tif(num[v] > 0)",
							"\t\t\t\tlow[u] = min(low[u], num[v]);",
						"\t\t\telse",
						"\t\t\t{",
							"\t\t\t\tdfs_tarjan(v);",
							"\t\t\t\tlow[u] = min(low[u], low[v]);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tif(num[u] == low[u])",
				"\t{",
					"\t\tcout << \"Found a SCC:\";",
					"\t\tint v;",
					"\t\tdo",
					"\t\t{",
						"\t\t\tv = st.top();",
						"\t\t\tst.pop();",
						"\t\t\tcout << \" \" << v;",
						"\t\t\tfound[v] = true;",
					"\t\t} while(v != u);",
					"\t\tcout << \"\\n\";",
				"\t}",
			"}\n",
        ],
        "description": "dfs_tarjan"
    },
	"tarjan": {
    	"prefix": "tarjan",
    	"body": [
			"\nvoid tarjan()",
			"{",
				"\tcounter = 0;",
				"\tlow.assign(n + 1, 0);",
				"\tnum.assign(n + 1, 0);",
				"\tfound.assign(n + 1, false);",
				"\tcounter = 0;",
				"\tst = stack<int>();\n",

				"\tfor(int i = 1; i <= n; i++)",
				"\t{",
					"\t\tif(!num[i])",
					"\t\t{",
						"\t\t\tdfs_tarjan(i);",
					"\t\t}",
				"\t}",
			"}\n",
        ],
        "description": "tarjan"
    },
	"dfs_bridge_cut_vertex": {
    	"prefix": "dfs_bridge_cut_vertex",
    	"body": [
			"\nvoid dfs_bridge_cut_vertex(int u, int p)",
			"{",
				"\tcounter++;",
				"\tnum[u] = low[u] = counter;",
				"\tint numChild = 0;\n",

				"\tfor(int v : graph[u])",
				"\t{",
					"\t\tif(v == p) continue;",
					"\t\tif(num[v] > 0)",
						"\t\t\tlow[u] = min(low[u], num[v]);",
					"\t\telse",
					"\t\t{",
						"\t\t\tdfs_bridge_cut_vertex(v, u);",
						"\t\t\tlow[u] = min(low[u], low[v]);",
						"\t\t\tnumChild++;",
						"\t\t\tif(low[v] > num[u])",
							"\t\t\t\tbridge.push_back(make_pair(u, v));",
						"\t\t\tif(low[v] >= num[u] && p != -1)",
							"\t\t\t\tisCut[u] = true;",
					"\t\t}",
				"\t}",
				"\tif(p == -1 && numChild > 1)",
					"\t\tisCut[u] = true;",
			"}\n",
        ],
        "description": "dfs_bridge_cut_vertex"
    },
	"findHamiltonPath": {
    	"prefix": "findHamiltonPath",
    	"body": [
			"\nvoid findHamiltonPath(int u)",
			"{",
				"\tif((int)path.size()== n)",
				"\t{",
					"\t\tbool hasCycle = false;",
					"\t\tfor(int v : graph[u])",
						"\t\t\tif(v == path[0])",
						"\t\t\t{",
							"\t\t\t\thasCycle = true;",
							"\t\t\t\tbreak;",
						"\t\t\t}",
					"\t\tif(hasCycle)",
						"\t\t\tcout << \"found a Hamilton cycle\";",
					"\t\telse",
						"\t\t\tcout << \"found a Hamilton path\";",
					"\t\treturn;",
				"\t}\n",

				"\tfor(int v : graph[u])",
				"\t{",
					"\t\tif(!visited[v])",
					"\t\t{",
						"\t\t\tvisited[v] = true;",
						"\t\t\tpath.push_back(v);",
						"\t\t\tfindHamiltonPath(v);",
						"\t\t\tpath.pop_back();",
						"\t\t\tvisited[v] = false;",
					"\t\t}",
				"\t}",
			"}\n",
        ],
        "description": "findHamiltonPath"
    },
	"findEulerPath_dfs": {
    	"prefix": "findEulerPath_dfs",
    	"body": [
			"\nvoid findEulerPath(int u)",
			"{",
				"\tfor(int v = 0; v < n; v++)",
				"\t{",
					"\t\tif(g[u][v] > 0)",
					"\t\t{",
						"\t\t\tg[u][v]--;",
						"\t\t\tg[v][u]--;",
						"\t\t\tfindEulerPath(v);",
					"\t\t}",
				"\t}",
				"\tresult.push_back(u);",
			"}\n",
        ],
        "description": "findEulerPath_dfs"
    },
	"findEulerPath_stack": {
    	"prefix": "findEulerPath_stack",
    	"body": [
			"\nvoid findEulerPath(int u)",
			"{",
				"\tstack<int> st;",
				"\tst.push(u);\n",

				"\twhile (!st.empty())",
				"\t{",
					"\t\tint v = st.top();",
					"\t\tint i;",
					"\t\tfor(i = 0; i < n; ++i)",
						"\t\t\tif(g[v][i] > 0)",
							"\t\t\t\tbreak;",
					"\t\tif(i == n)",
					"\t\t{",
						"\t\t\tres.push_back(v);",
						"\t\t\tst.pop();",
					"\t\t}",
					"\t\telse",
					"\t\t{",
						"\t\t\t--g[v][i];",
						"\t\t\t--g[i][v];",
						"\t\t\tst.push(i);",
					"\t\t}",
				"\t}",
			"}\n",
        ],
        "description": "findEulerPath_stack"
    },
	"findEulerCycle": {
    	"prefix": "findEulerCycle",
    	"body": [
			"\nvoid findEulerCycle()",
			"{",
				"\tint u = -1, v = -1;",
				"\tbool isConnected = true, bad = false;\n",

				"\tfor(int i = 0; i < n; i++)",
				"\t{",
					"\t\tint cnt = 0;",
					"\t\tfor(int j = 0; j < n; j++)",
						"\t\t\tcnt += g[i][j];\n",

					"\t\tif(cnt % 2 == 1)",
					"\t\t{",
						"\t\t\tif(u == -1)",
							"\t\t\t\tu = i;",
						"\t\t\telse if(v == -1)",
							"\t\t\t\tv = i;",
						"\t\t\telse",
						"\t\t\t{",
							"\t\t\t\tbad = true;",
							"\t\t\t\tbreak;",
						"\t\t\t}",
					"\t\t}",
				"\t}\n",

				"\tif(bad)",
				"\t{",
					"\t\tcout << \"Graph does not have Euler Path\";",
					"\t\treturn;",
				"\t}",
				"\tif(u != -1)",
				"\t{",
					"\t\tg[u][v]++; g[v][u]++;",
					"\t\tm++;",
				"\t}",
				"\tfindEulerPath(0);",
				"\tif((int)result.size() != m + 1)",
				"\t{",
					"\t\tcout << \"Graph does not have Euler Path\";",
					"\t\treturn;",
				"\t}",
				"\tif(u == -1)",
				"\t{",
					"\t\tcout << \"Euler cycle: \";",
					"\t\tfor(int v : result)",
						"\t\t\tcout << v << \" \";",
					"\t\treturn;",
				"\t}\n",

				"\tfor(int i = 0; i < (int)result.size(); i++)",
				"\t{",
					"\t\tif((result[i] == u && result[i + 1] == v) || (result[i] == v && result[i + 1] == u))",
					"\t\t{",
						"\t\t\tfor(int j = 1; j <= i; j++)",
							"\t\t\t\tresult.push_back(result[j]);",
						"\t\t\tresult.erase(result.begin(), result.begin() + i + 1);",
						"\t\t\tbreak;",
					"\t\t}",
				"\t}\n",

				"\tcout << \"Euler Path: \"",
				"\tfor(int v : result)",
					"\t\tcout << v << \" \";",
			"}\n",
        ],
        "description": "findEulerPath"
    },
	"Edge": {
    	"prefix": "Edge",
    	"body": [
			"\nstruct Edge",
			"{",
				"\tint u, v, w;",
				"\tEdge(int u = 0, int v = 0, int w = 0)",
					"\t\t: u(u), v(v), w(w) {}",
				"\tbool operator<(const Edge& other) const",
    			"\t{",
        			"\t\treturn w < other.w;",
				"\t}",
			"};",
        ],
        "description": "Edge"
    },
	"Graph": {
    	"prefix": "Graph",
    	"body": [
			"\nstruct Graph",
			"{\n",

				"\n\tGraph()",
				"\t{}\n",

			"};\n",
        ],
        "description": "Graph"
    },
	"DisjointSet": {
    	"prefix": "DisjointSet",
    	"body": [
			"\nstruct DisjointSet",
			"{",
				"\tvector<int> parent, Rank;",
				"\tDisjointSet(int n): parent(n + 1), Rank(n + 1, 0)",
				"\t{",
					"\t\tfor (int i=1; i<=n; i++) parent[i] = i;",
				"\t}",
				"\tint findSet(int u)",
				"\t{",
					"\t\tif (parent[u] != u) parent[u] = findSet(parent[u]);",
					"\t\treturn parent[u];",
				"\t}",
				"\tbool unionSet(int u, int v)",
				"\t{",
					"\t\tint pu = findSet(u), pv = findSet(v);",
					"\t\tif(pu == pv) return false;",
					"\t\tif(Rank[pu] > Rank[pv]) parent[pv] = pu;",
					"\t\telse if(Rank[pu] < Rank[pv]) parent[pu] = pv;",
					"\t\telse",
					"\t\t{",
						"\t\t\tparent[pv] = pu;",
						"\t\t\tRank[pu]++;",
					"\t\t}",
					"\t\treturn true;",
				"\t}",
			"};\n",
        ],
        "description": "DisjointSet"
    },
}